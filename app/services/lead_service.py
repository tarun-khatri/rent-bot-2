"""
AI-powered lead management service with strict flow control.
All responses are generated by AI with stage-specific prompts and business rules.
"""

import logging
import os
import re
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
from flask import current_app
from app.services.database_service import db_service
from app.services.gemini_service import gemini_service
from app.config import get_current_time

logger = logging.getLogger(__name__)


class LeadService:
    """AI-powered service for managing lead qualification and conversation flows"""
    
    def __init__(self):
        """Initialize the lead service""" 
        # Removed hardcoded greeting patterns - now using intelligent context-aware detection
    
    def process_lead_message(self, phone_number: str, name: str, message: str) -> str:
        """Main entry point for processing lead messages with AI responses"""
        try:
            logger.info(f"Processing message from {name} ({phone_number}): {message[:50]}...")
            
            # Get or create lead
            lead = db_service.get_lead_by_phone(phone_number)
            if not lead:
                lead = db_service.create_lead(phone_number, name)
                logger.info(f"New lead created: {lead['id']}")
            
            # Check for duplicate message processing (prevent double responses)
            recent_messages = db_service.get_conversation_history(lead['id'], limit=3)
            if recent_messages:
                last_user_message = None
                for msg in reversed(recent_messages):
                    if msg.get('message_type') == 'user':
                        last_user_message = msg.get('content', '').strip()
                        break
                
                # If this is the same message as the last one, don't process again
                if last_user_message and last_user_message == message.strip():
                    logger.info(f"Duplicate message detected for lead {lead['id']}, skipping processing")
                    return "אני כבר עיבדתי את ההודעה הזו. איך אני יכול לעזור לך?"
            
            # Log user message
            db_service.log_conversation(lead['id'], 'user', message)
            
            # Check for greeting, but be smart about when to restart (like a human would)
            if self._should_restart_conversation(message, lead):
                logger.info(f"Intelligently restarting conversation for lead {lead['id']} based on context")
                db_service.update_lead(lead['id'], {'stage': 'new'})
                lead = db_service.get_lead_by_phone(phone_number)  # Refresh lead data
            
            # Process based on current stage with AI
            response = self._process_by_stage_with_ai(lead, message)
            
            # Log bot response
            db_service.log_conversation(lead['id'], 'bot', response)
            
            logger.info(f"AI response generated for lead {lead['id']}, length: {len(response)}")
            return response
            
        except Exception as e:
            logger.error(f"Error processing lead message: {e}")
            return "מצטער, יש לי בעיה טכנית. אנא נסה שוב בעוד כמה דקות."
    
    def _process_by_stage_with_ai(self, lead: Dict, message: str) -> str:
        """Process message using AI with intelligent intent understanding"""
        stage = lead.get('stage', 'new')
        
        logger.info(f"Processing AI response for lead {lead['id']} in stage: {stage}")
        
        # Get conversation history for context
        conversation_history = db_service.get_conversation_history(lead['id'], limit=25)
        
        # Use AI to analyze user intent and extract information
        intent_analysis = gemini_service.analyze_user_intent(message, stage, lead)
        logger.info(f"AI intent analysis for lead {lead['id']}: {intent_analysis.get('intent')}")
        
        # Handle different intents intelligently
        if intent_analysis.get('intent') == 'frustration':
            return self._handle_frustration_with_ai(lead, message, conversation_history, intent_analysis)
        
        # Extract and update data from user message
        extracted_data = intent_analysis.get('extracted_data', {})
        if extracted_data:
            self._update_lead_with_extracted_data(lead, extracted_data)
            # Refresh lead data
            lead = db_service.get_lead_by_phone(lead['phone_number'])
        
        # Handle stage transitions based on current stage and intent
        if stage == 'new':
            return self._handle_new_lead_with_ai(lead, message, conversation_history)
        elif stage in ['gate_question_payslips', 'gate_question_deposit', 'gate_question_move_date']:
            return self._handle_gate_questions_with_ai(lead, message, conversation_history, intent_analysis)
        elif stage == 'collecting_profile':
            return self._handle_profile_collection_with_ai(lead, message, conversation_history, intent_analysis)
        elif stage == 'qualified':
            return self._handle_qualified_lead_with_ai(lead, message, conversation_history)
        elif stage == 'scheduling_in_progress':
            return self._handle_scheduling_in_progress_with_ai(lead, message, conversation_history)
        elif stage == 'tour_scheduled':
            return self._handle_tour_scheduled_with_ai(lead, message, conversation_history)
        elif stage in ['gate_failed', 'no_fit', 'future_fit']:
            return self._handle_ended_conversation_with_ai(lead, message, conversation_history)
        else:
            logger.warning(f"Unknown stage for lead {lead['id']}: {stage}")
            return self._handle_unknown_stage_with_ai(lead, message, conversation_history)
    
    def _check_for_qualification_restart(self, lead: Dict, message: str, conversation_history: List[Dict]) -> Optional[str]:
        """
        COMPREHENSIVE EDGE CASE HANDLER
        Checks if user wants to restart qualification process or change previous answers
        """
        stage = lead['stage']
        message_lower = message.lower().strip()
        
        # Edge Case 1: User in failed/ended stage but provides qualification info
        if stage in ['gate_failed', 'no_fit', 'future_fit']:
            logger.info(f"Lead {lead['id']} in failed stage, checking message: '{message_lower}'")
            
            # Check for deposit mentions FIRST (more specific)
            deposit_keywords = ['deposit', 'guarantee', 'month', 'ערבות', 'חודש', 'pay', 'afford', 'can pay', 'משלם', 'יכול לשלם']
            found_deposit_keyword = next((kw for kw in deposit_keywords if kw in message_lower), None)
            
            if found_deposit_keyword:
                logger.info(f"Lead {lead['id']} providing deposit info after failed stage - found keyword: '{found_deposit_keyword}'")
                return self._handle_post_failure_deposit_claim(lead, message, conversation_history)
            
            # Check for payslips mentions (but NOT if it's about deposit)
            if any(keyword in message_lower for keyword in ['payslip', 'salary', 'income', 'תלוש']) and not any(dep_word in message_lower for dep_word in ['deposit', 'guarantee', 'ערבות']):
                logger.info(f"Lead {lead['id']} providing payslips info after gate_failed - restarting qualification")
                return self._restart_payslips_qualification(lead, message, conversation_history)
            
            # Check for move date changes - be more specific
            move_date_indicators = ['days', 'week', 'soon', 'immediately', 'יום', 'שבוע', 'מיד', 'בקרוב']
            if (any(indicator in message_lower for indicator in move_date_indicators) and 
                not is_about_deposit and
                len(message_lower) > 5):  # Avoid single word responses
                logger.info(f"Lead {lead['id']} providing new move date after failed stage")
                return self._handle_post_failure_move_date(lead, message, conversation_history)
        
        # Edge Case 2: User wants to restart entire process
        restart_phrases = ['restart', 'start over', 'begin again', 'מחדש', 'שוב', 'מהתחלה']
        if any(phrase in message_lower for phrase in restart_phrases):
            logger.info(f"Lead {lead['id']} explicitly requesting process restart")
            return self._restart_entire_qualification(lead, conversation_history)
        
        # Edge Case 3: User contradicts previous answer in same conversation - BUT be more lenient
        if stage in ['gate_question_payslips', 'gate_question_deposit', 'gate_question_move_date']:
            contradiction_result = self._check_for_contradictions(lead, message, conversation_history)
            if contradiction_result:
                return contradiction_result
        
        # Edge Case 4: User asking questions instead of answering - handle gracefully
        if self._is_asking_question(message) and stage.startswith('gate_question'):
            logger.info(f"Lead {lead['id']} asking question instead of answering in {stage}")
            return self._handle_user_question(lead, message, conversation_history)
        
        # Edge Case 5: User providing irrelevant information - be less strict
        if self._is_clearly_off_topic(message, stage):
            logger.info(f"Lead {lead['id']} clearly off-topic in stage {stage}")
            return self._redirect_to_current_question(lead, conversation_history)
        
        return None
    
    def _restart_payslips_qualification(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Restart qualification when user claims to have payslips after saying no"""
        logger.info(f"Restarting payslips qualification for lead {lead['id']}")
        
        # Analyze the new payslips claim
        yes_no_response = self._analyze_yes_no_response(message, context='payslips')
        
        if yes_no_response == 'yes':
            # User now claims to have payslips - restart the process
            db_service.update_lead(lead['id'], {
                'stage': 'gate_question_deposit',
                'has_payslips': True
            })
            updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
            return gemini_service.generate_stage_response('gate_question_deposit', updated_lead, conversation_history, message)
        else:
            # Still unclear - ask for clarification
            return gemini_service.generate_stage_response(lead['stage'], lead, conversation_history, message)
    
    def _handle_post_failure_deposit_claim(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle deposit claims after failed qualification with better understanding"""
        logger.info(f"Handling post-failure deposit claim for lead {lead['id']}")
        logger.info(f"Lead status - payslips: {lead.get('has_payslips')}, deposit: {lead.get('can_pay_deposit')}")
        
        # If they already failed on payslips, we need payslips first
        if lead.get('has_payslips') == False:
            logger.info(f"Lead {lead['id']} failed payslips, asking for payslips first")
            return gemini_service.generate_stage_response('gate_failed', lead, conversation_history, 
                "עדיין צריך גם תלושי שכר. יש לך תלושי שכר מהחודשיים האחרונים?")
        
        # Enhanced deposit claim analysis with context
        yes_no_response = self._analyze_yes_no_response(message, context='deposit')
        logger.info(f"Deposit claim analysis for lead {lead['id']}: '{message}' -> '{yes_no_response}'")
        
        # More liberal acceptance of deposit agreement
        if (yes_no_response == 'yes' or 
            any(phrase in message.lower() for phrase in [
                'ok', 'אוקיי', 'בסדר', 'טוב', 'ill pay', 'אשלם', 'יכול לשלם', 
                'can pay', 'אתן', 'נתן', 'provide', 'אספק'
            ])):
            logger.info(f"Lead {lead['id']} agreed to pay deposit - restarting qualification")
            db_service.update_lead(lead['id'], {
                'stage': 'gate_question_move_date',
                'can_pay_deposit': True
            })
            updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
            return gemini_service.generate_stage_response('gate_question_move_date', updated_lead, conversation_history, message)
        
        # If clearly negative
        if yes_no_response == 'no':
            logger.info(f"Lead {lead['id']} clearly cannot pay deposit - staying failed")
            return gemini_service.generate_stage_response('gate_failed', lead, conversation_history, message)
        
        # If unclear, ask for clarification with empathy
        logger.info(f"Lead {lead['id']} deposit response unclear - asking for clarification")
        clarification_prompt = f"לא לגמרי הבנתי. האם יש לך יכולת להפקיד ערבות של 2 חודשי שכירות? (כן/לא)"
        return gemini_service.generate_stage_response('gate_failed', lead, conversation_history, clarification_prompt)
    
    def _handle_post_failure_move_date(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle move date changes after failed qualification"""
        logger.info(f"Handling post-failure move date for lead {lead['id']}")
        
        # Check if they passed other gate questions first
        if not lead.get('has_payslips') or not lead.get('can_pay_deposit'):
            return gemini_service.generate_stage_response('gate_failed', lead, conversation_history, 
                "עדיין צריך לעבור את כל בדיקות הכשרות קודם.")
        
        # Evaluate new move date
        days_until_move = self._extract_move_in_days(message)
        max_days = current_app.config.get('MAX_MOVE_IN_DAYS', 60)
        
        if days_until_move <= max_days:
            db_service.update_lead(lead['id'], {
                'stage': 'collecting_profile',
                'move_in_date': message.strip()
            })
            updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
            return gemini_service.generate_stage_response('collecting_profile', updated_lead, conversation_history, message)
        
        return gemini_service.generate_stage_response('future_fit', lead, conversation_history, message)
    
    def _restart_entire_qualification(self, lead: Dict, conversation_history: List[Dict]) -> str:
        """Restart the entire qualification process"""
        logger.info(f"Restarting entire qualification for lead {lead['id']}")
        
        # Reset lead to initial state
        db_service.update_lead(lead['id'], {
            'stage': 'gate_question_payslips',
            'has_payslips': None,
            'can_pay_deposit': None,
            'move_in_date': None,
            'rooms': None,
            'budget': None,
            'has_parking': None,
            'preferred_area': None
        })
        
        updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
        return gemini_service.generate_stage_response('gate_question_payslips', updated_lead, conversation_history, "מתחילים מחדש")
    
    def _check_for_contradictions(self, lead: Dict, message: str, conversation_history: List[Dict]) -> Optional[str]:
        """Check if current message contradicts previous answers - but only for SAME question type"""
        stage = lead['stage']
        message_lower = message.lower().strip()
        
        # Only check for contradictions in active qualification stages
        if stage not in ['gate_question_payslips', 'gate_question_deposit', 'gate_question_move_date']:
            return None
        
        # Get context for current stage
        current_context = {
            'gate_question_payslips': 'payslips',
            'gate_question_deposit': 'deposit', 
            'gate_question_move_date': 'move_date'
        }.get(stage)
        
        # Check conversation history for previous answers to THE SAME QUESTION TYPE
        try:
            # Only look at the last 2-3 user messages to avoid false positives
            recent_user_messages = [conv for conv in conversation_history[-6:] if conv.get('message_type') == 'user'][-2:]
            
            for conv in reversed(recent_user_messages):
                previous_content = conv.get('content', '').lower()
                
                # Only check contradiction if discussing same topic
                is_same_topic = False
                if current_context == 'payslips' and any(word in previous_content for word in ['תלוש', 'salary', 'payslip']):
                    is_same_topic = True
                elif current_context == 'deposit' and any(word in previous_content for word in ['ערבות', 'deposit', 'guarantee', 'pay', 'שלם']):
                    is_same_topic = True
                elif current_context == 'move_date' and any(word in previous_content for word in ['יום', 'day', 'week', 'שבוע', 'חודש']):
                    is_same_topic = True
                
                if is_same_topic:
                    previous_response = self._analyze_yes_no_response(previous_content, current_context)
                    current_response = self._analyze_yes_no_response(message, current_context)
                    
                    # Only flag as contradiction if CLEARLY opposite responses on SAME topic
                    if (previous_response in ['yes', 'no'] and current_response in ['yes', 'no'] and 
                        previous_response != current_response):
                        logger.info(f"Same-topic contradiction detected for lead {lead['id']}: {previous_response} vs {current_response} on {current_context}")
                        return self._handle_contradiction(lead, message, conversation_history, previous_response, current_response)
                    
        except Exception as e:
            logger.error(f"Error checking for contradictions for lead {lead['id']}: {e}")
            # Continue without contradiction checking if there's an error
        
        return None
    
    def _handle_contradiction(self, lead: Dict, message: str, conversation_history: List[Dict], 
                            previous: str, current: str) -> str:
        """Handle when user gives contradictory answers"""
        logger.info(f"Handling contradiction for lead {lead['id']}: {previous} -> {current}")
        
        # Use the most recent answer and acknowledge the change
        confirmation_message = f"הבנתי שהתשובה שלך השתנתה מ'{previous}' ל'{current}'. נמשיך עם התשובה החדשה."
        
        # Process the new answer based on current stage
        stage = lead['stage']
        if stage == 'gate_question_payslips':
            return self._handle_payslips_with_ai(lead, message, conversation_history)
        elif stage == 'gate_question_deposit':
            return self._handle_deposit_with_ai(lead, message, conversation_history)
        elif stage == 'gate_question_move_date':
            return self._handle_move_date_with_ai(lead, message, conversation_history)
        
        return gemini_service.generate_stage_response(stage, lead, conversation_history, message)
    
    def _is_asking_question(self, message: str) -> bool:
        """Check if user is asking a question instead of answering"""
        message_lower = message.lower().strip()
        
        # Don't treat area responses as questions  
        if any(area_indicator in message_lower for area_indicator in ['anywhere', 'any', 'כל', 'לא משנה', 'בכל']):
            return False
            
        question_indicators = [
            '?', 'how much', 'what is', 'when can', 'where is', 'why', 'who',
            'איך', 'מה זה', 'מתי אפשר', 'איפה נמצא', 'למה', 'מי', 'כמה עולה', 'מחיר'
        ]
        return any(indicator in message_lower for indicator in question_indicators)
    
    def _is_clearly_off_topic(self, message: str, stage: str) -> bool:
        """Check if message is CLEARLY off-topic for current stage - be more lenient"""
        message_lower = message.lower().strip()
        
        # During gate questions, only flag as off-topic if it's REALLY unrelated
        if stage.startswith('gate_question'):
            # Only flag as off-topic if discussing complex property details
            clearly_off_topic = [
                'floor plan', 'square meters', 'exact address', 'renovation', 'furniture', 
                'תוכנית דירה', 'מטרים רבועים', 'כתובת מדויקת', 'שיפוצים', 'ריהוט'
            ]
            # Don't flag basic questions about rooms/price as off-topic - they might be clarifying
            return any(keyword in message_lower for keyword in clearly_off_topic)
        
        return False
    
    def _handle_user_question(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle when user asks a question instead of answering"""
        stage = lead['stage']
        
        # Brief answer + redirect to current question
        if stage == 'gate_question_payslips':
            return gemini_service.generate_stage_response(stage, lead, conversation_history, 
                "אענה על זה בהמשך. קודם כל, יש לך תלושי שכר מהחודשיים האחרונים?")
        elif stage == 'gate_question_deposit':
            return gemini_service.generate_stage_response(stage, lead, conversation_history, 
                "נדבר על זה אחר כך. עכשיו חשוב לי לדעת - יש לך יכולת להפקיד ערבות של 2 חודשי שכירות?")
        elif stage == 'gate_question_move_date':
            return gemini_service.generate_stage_response(stage, lead, conversation_history, 
                "אענה על זה ברגע שנסיים. מתי אתה מתכנן להיכנס לדירה?")
        else:
            return gemini_service.generate_stage_response(stage, lead, conversation_history, message)
    
    def _redirect_to_current_question(self, lead: Dict, conversation_history: List[Dict]) -> str:
        """Redirect user back to current stage question"""
        stage = lead['stage']
        
        if stage == 'gate_question_payslips':
            redirect_message = "בואו נתמקד קודם בבדיקות הכשרות. יש לך תלושי שכר מהחודשיים האחרונים?"
        elif stage == 'gate_question_deposit':
            redirect_message = "נדבר על זה אחר כך. עכשיו אני צריך לדעת - יש לך יכולת להפקיד ערבות של 2 חודשי שכירות?"
        elif stage == 'gate_question_move_date':
            redirect_message = "מתי אתה מתכנן להיכנס לדירה?"
        else:
            redirect_message = "בואו נמשיך עם התהליך השלב אחר שלב"
        
        return gemini_service.generate_stage_response(stage, lead, conversation_history, redirect_message)
    
    def _update_lead_with_extracted_data(self, lead: Dict, extracted_data: Dict) -> None:
        """Update lead with data extracted by AI"""
        updates = {}
        
        # Map extracted data to database fields
        if extracted_data.get('has_payslips') is not None:
            updates['has_payslips'] = extracted_data['has_payslips']
        if extracted_data.get('can_pay_deposit') is not None:
            updates['can_pay_deposit'] = extracted_data['can_pay_deposit']
        if extracted_data.get('move_in_date'):
            updates['move_in_date'] = extracted_data['move_in_date']
        if extracted_data.get('rooms'):
            updates['rooms'] = extracted_data['rooms']
        if extracted_data.get('budget'):
            updates['budget'] = extracted_data['budget']
        if extracted_data.get('has_parking') is not None:
            updates['has_parking'] = extracted_data['has_parking']
        if extracted_data.get('preferred_project'):
            updates['preferred_area'] = extracted_data['preferred_project']
        if extracted_data.get('preferred_floor_min'):
            updates['preferred_floor_min'] = extracted_data['preferred_floor_min']
        if extracted_data.get('preferred_floor_max'):
            updates['preferred_floor_max'] = extracted_data['preferred_floor_max']
        if extracted_data.get('needs_furnished') is not None:
            updates['needs_furnished'] = extracted_data['needs_furnished']
        if extracted_data.get('pet_owner') is not None:
            updates['pet_owner'] = extracted_data['pet_owner']
        if extracted_data.get('email'):
            updates['email'] = extracted_data['email']
        
        if updates:
            db_service.update_lead(lead['id'], updates)
            logger.info(f"Updated lead {lead['id']} with extracted data: {updates}")

    def _handle_frustration_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict], intent_analysis: Dict) -> str:
        """Handle frustrated users with empathy and AI understanding"""
        logger.info(f"Handling frustration for lead {lead['id']}")
        
        # Use AI to generate empathetic response
        return gemini_service.generate_stage_response('frustration', lead, conversation_history, message)

    def _handle_gate_questions_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict], intent_analysis: Dict) -> str:
        """Handle gate questions using AI intent understanding"""
        stage = lead['stage']
        logger.info(f"Handling gate question {stage} for lead {lead['id']} with AI")
        
        # Check if we have clear answers from AI analysis
        extracted_data = intent_analysis.get('extracted_data', {})
        
        if stage == 'gate_question_payslips':
            if extracted_data.get('has_payslips') is not None:
                if extracted_data['has_payslips']:
                    # Passed payslips gate
                    db_service.update_lead(lead['id'], {
                        'stage': 'gate_question_deposit',
                        'has_payslips': True
                    })
                    updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
                    return gemini_service.generate_stage_response('gate_question_deposit', updated_lead, conversation_history, message)
                else:
                    # Failed payslips gate
                    db_service.update_lead(lead['id'], {
                        'stage': 'gate_failed',
                        'has_payslips': False
                    })
                    updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
                    return gemini_service.generate_stage_response('gate_failed', updated_lead, conversation_history, message)
        
        elif stage == 'gate_question_deposit':
            if extracted_data.get('can_pay_deposit') is not None:
                if extracted_data['can_pay_deposit']:
                    # Passed deposit gate
                    db_service.update_lead(lead['id'], {
                        'stage': 'gate_question_move_date',
                        'can_pay_deposit': True
                    })
                    updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
                    return gemini_service.generate_stage_response('gate_question_move_date', updated_lead, conversation_history, message)
                else:
                    # Failed deposit gate
                    db_service.update_lead(lead['id'], {
                        'stage': 'gate_failed',
                        'can_pay_deposit': False
                    })
                    updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
                    return gemini_service.generate_stage_response('gate_failed', updated_lead, conversation_history, message)
        
        elif stage == 'gate_question_move_date':
            if extracted_data.get('move_in_date'):
                # Check if move-in date is acceptable
                days_until_move = self._extract_move_in_days(extracted_data['move_in_date'])
                max_days = current_app.config.get('MAX_MOVE_IN_DAYS', 60)
                
                if days_until_move <= max_days:
                    # Good move-in date
                    db_service.update_lead(lead['id'], {
                        'stage': 'collecting_profile',
                        'move_in_date': extracted_data['move_in_date']
                    })
                    updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
                    return gemini_service.generate_stage_response('collecting_profile', updated_lead, conversation_history, message)
                else:
                    # Too far in future
                    db_service.update_lead(lead['id'], {
                        'stage': 'future_fit',
                        'move_in_date': extracted_data['move_in_date']
                    })
                    updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
                    return gemini_service.generate_stage_response('future_fit', updated_lead, conversation_history, message)
        
        # If AI needs clarification, ask for it
        if intent_analysis.get('needs_clarification'):
            clarification_question = intent_analysis.get('clarification_question')
            if clarification_question:
                return clarification_question
        
        # Default to AI-generated response for the current stage
        return gemini_service.generate_stage_response(stage, lead, conversation_history, message)

    def _handle_new_lead_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle new lead with AI-generated welcome and first gate question"""
        logger.info(f"Handling new lead {lead['id']} with AI")
        
        # Update stage to first gate question
        db_service.update_lead(lead['id'], {'stage': 'gate_question_payslips'})
        
        # Get AI response for new lead welcome
        return gemini_service.generate_stage_response('new', lead, conversation_history, message)
    
    
    def _handle_profile_collection_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict], intent_analysis: Dict = None) -> str:
        """Handle profile collection with AI intent understanding"""
        logger.info(f"Collecting profile info for lead {lead['id']} with AI")
        
        # Check what profile information is missing
        missing_info = self._get_missing_profile_info(lead)
        
        if not missing_info:
            # Profile is complete, search for properties
            return self._complete_profile_and_search_with_ai(lead, conversation_history)
        
        # If AI needs clarification, ask for it
        if intent_analysis and intent_analysis.get('needs_clarification'):
            clarification_question = intent_analysis.get('clarification_question')
            if clarification_question:
                return clarification_question
        
        # Get updated lead data for AI context
        current_lead = db_service.get_lead_by_phone(lead['phone_number'])
        return gemini_service.generate_stage_response('collecting_profile', current_lead, conversation_history, message)
    
    def _handle_qualified_lead_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle qualified lead with AI responses"""
        logger.info(f"Handling qualified lead {lead['id']} with AI")
        
        # Check if they want to schedule a tour (HIGHEST PRIORITY)
        if self._is_scheduling_request(message):
            return self._handle_scheduling_request_with_ai(lead, message, conversation_history)
        
        # Check if they're asking for property recommendations
        if self._is_property_request(message):
            return self._search_and_present_properties_with_ai(lead, conversation_history)
        
        # For qualified leads, let AI decide if they should see properties
        # The AI will be instructed to offer properties proactively
        ai_response = gemini_service.generate_stage_response('qualified', lead, conversation_history, message)
        
        # If AI suggests showing properties, do it (but only if not scheduling)
        if self._ai_suggests_showing_properties(ai_response) and not self._is_scheduling_request(message):
            logger.info(f"AI suggested showing properties to lead {lead['id']}")
            return self._search_and_present_properties_with_ai(lead, conversation_history)
        
        return ai_response
    
    def _handle_scheduling_in_progress_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle lead who is in the process of scheduling a tour"""
        logger.info(f"Handling scheduling in progress for lead {lead['id']} with AI")
        
        # Check if they're confirming they booked an appointment
        if self._is_booking_confirmation(message):
            logger.info(f"Lead {lead['id']} confirmed booking - moving to tour_scheduled")
            db_service.update_lead(lead['id'], {'stage': 'tour_scheduled'})
            updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
            return self._generate_booking_confirmation_message()
        
        # Check if they need help with the Calendly link
        if self._is_calendly_help_request(message):
            logger.info(f"Lead {lead['id']} needs help with Calendly")
            calendly_link = os.getenv('CALENDLY_LINK')
            return self._generate_calendly_help_message(calendly_link)
        
        # Check if they want to go back to seeing more properties
        if self._is_property_request(message):
            logger.info(f"Lead {lead['id']} wants to see more properties before scheduling")
            db_service.update_lead(lead['id'], {'stage': 'qualified'})
            updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
            return self._search_and_present_properties_with_ai(updated_lead, conversation_history)
        
        # General response for scheduling stage
        return gemini_service.generate_stage_response('scheduling_in_progress', lead, conversation_history, message)
    
    def _handle_tour_scheduled_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle tour scheduled lead with AI"""
        logger.info(f"Handling tour scheduled lead {lead['id']} with AI")
        return gemini_service.generate_stage_response('tour_scheduled', lead, conversation_history, message)
    
    def _handle_ended_conversation_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle ended conversations with AI"""
        stage = lead.get('stage')
        logger.info(f"Handling ended conversation for lead {lead['id']} in stage {stage} with AI")
        return gemini_service.generate_stage_response(stage, lead, conversation_history, message)
    
    def _handle_unknown_stage_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle unknown stage with AI"""
        logger.warning(f"Unknown stage for lead {lead['id']}: {lead.get('stage')}")
        # Default to qualified stage for unknown stages
        return gemini_service.generate_stage_response('qualified', lead, conversation_history, message)
    
    def _complete_profile_and_search_with_ai(self, lead: Dict, conversation_history: List[Dict]) -> str:
        """Complete profile collection and search for properties with AI"""
        logger.info(f"Profile complete for lead {lead['id']}, searching properties with AI")
        
        # Update stage to qualified
        db_service.update_lead(lead['id'], {'stage': 'qualified'})
        
        # Search for matching properties
        units = self._search_matching_properties(lead)
        
        if units:
            # Found matching properties, generate AI recommendation and send images
            ai_response = gemini_service.generate_property_recommendation(lead, units)
            
            # Send property images after AI text response
            try:
                from app.services.messaging_service import messaging_service
                messaging_service.send_property_images(lead['id'], units)
                logger.info(f"Property images sent to lead {lead['id']}")
            except Exception as e:
                logger.error(f"Failed to send property images to lead {lead['id']}: {e}")
            
            return ai_response
        else:
            # No matching properties, generate AI response for alternatives
            return gemini_service.generate_no_properties_response(lead, conversation_history)
    
    def _search_and_present_properties_with_ai(self, lead: Dict, conversation_history: List[Dict]) -> str:
        """Search and present properties with AI"""
        logger.info(f"Searching properties for qualified lead {lead['id']} with AI")
        
        units = self._search_matching_properties(lead)
        
        if units:
            # Generate AI recommendation and send images
            ai_response = gemini_service.generate_property_recommendation(lead, units)
            
            # Send property images after AI text response
            try:
                from app.services.messaging_service import messaging_service
                messaging_service.send_property_images(lead['id'], units)
                logger.info(f"Property images sent to qualified lead {lead['id']}")
            except Exception as e:
                logger.error(f"Failed to send property images to qualified lead {lead['id']}: {e}")
            
            return ai_response
        else:
            return gemini_service.generate_no_properties_response(lead, conversation_history)
    
    def _handle_scheduling_request_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle scheduling request with AI"""
        logger.info(f"Handling scheduling request for lead {lead['id']} with AI")
        
        # Get Calendly link from environment with fallback
        calendly_link = os.getenv('CALENDLY_LINK')
        
        if not calendly_link:
            logger.warning("No CALENDLY_LINK configured in environment, using manual scheduling")
            # Update stage to scheduling in progress
            db_service.update_lead(lead['id'], {'stage': 'scheduling_in_progress'})
            return self._generate_manual_scheduling_message()
        
        # Update stage to scheduling in progress
        db_service.update_lead(lead['id'], {'stage': 'scheduling_in_progress'})
        
        # Generate scheduling message with Calendly link
        return self._generate_calendly_message(calendly_link)
    
    def _generate_calendly_message(self, calendly_link: str) -> str:
        """Generate scheduling message with Calendly link and confirmation instructions"""
        return f"""🎉 מעולה! בואו נתאם פגישה לצפייה בדירות!

👇 לחץ על הקישור הזה לבחירת התאריך והשעה שנוחים לך:

{calendly_link}

📝 אחרי שתזמין פגישה בקלנדלי, אנא חזור לכאן ואשר לי שקבעת - כדי שאוכל להכין את כל הפרטים עבורך!

⏰ הפגישה תקח בערך 30-45 דקות, ואני אלווה אותך לראות את הדירות שהכי מתאימות לתקציב ולדרישות שלך.

💡 טיפ: מומלץ לקבוע לפחות יום מראש כדי שאוכל להכין עבורך את הדירות הטובות ביותר!

יש לך שאלות נוספות? אני כאן לעזור! 😊"""
    
    def _generate_manual_scheduling_message(self) -> str:
        """Generate manual scheduling message when Calendly is not available"""
        return """🎉 מעולה! בואו נתאם פגישה לצפייה בדירות!

📅 אני אתאם איתך פגישה באופן אישי.

⏰ אנא ספר לי מתי נוח לך:
• איזה יום מהשבוע הבא?
• איזה שעה מועדפת עליך? (בוקר/צהריים/אחר הצהריים)

📍 הפגישה תקח בערך 30-45 דקות, ואני אלווה אותך לראות את הדירות שהכי מתאימות לתקציב ולדרישות שלך.

💡 אני אכין עבורך מראש את הדירות הטובות ביותר!

כתוב לי את הזמן שנוח לך ואני אסדר הכל! 😊"""
    
    def _is_booking_confirmation(self, message: str) -> bool:
        """Check if message is confirming that they booked an appointment"""
        message_lower = message.lower().strip()
        
        confirmation_phrases = [
            'קבעתי', 'הזמנתי', 'תיאמתי', 'רשמתי',
            'booked', 'scheduled', 'confirmed', 'set',
            'קיבלתי אישור', 'נקבע', 'זומן', 'עשיתי', 'סידרתי',
            'done', 'finished', 'completed'
        ]
        
        for phrase in confirmation_phrases:
            if phrase in message_lower:
                return True
        
        return False
    
    def _is_calendly_help_request(self, message: str) -> bool:
        """Check if they need help with the Calendly booking process"""
        message_lower = message.lower().strip()
        
        help_phrases = [
            'לא עובד', 'בעיה', 'עזרה', 'לא מצליח', 'לא יכול',
            'not working', 'help', 'problem', 'issue', 'error',
            'כשל', 'תקלה', 'לא פותח', 'לא נטען',
            'cant', "can't", 'cannot', 'broken', 'stuck'
        ]
        
        for phrase in help_phrases:
            if phrase in message_lower:
                return True
        
        return False
    
    def _generate_booking_confirmation_message(self) -> str:
        """Generate message confirming that appointment was booked"""
        return """🎉 מעולה! קיבלתי את האישור שקבעת פגישה!

✅ אני מכין עבורך את כל הפרטים לפגישה ואשלח לך תזכורות לפני המועד.

📋 במהלך הפגישה נראה ביחד:
• את הדירות שהכי מתאימות לתקציב שלך
• נבדוק את המיקום והסביבה
• נעבור על כל הפרטים החשובים

📞 אם יש לך שאלות נוספות לפני הפגישה - אני כאן!

מחכה לפגוש אותך! 😊"""
    
    def _generate_calendly_help_message(self, calendly_link: str) -> str:
        """Generate help message when user has issues with Calendly"""
        return f"""😔 מצטער שיש בעיה! בואו ננסה שוב:

🔧 דברים לבדוק:
• ודא שהקישור נפתח בדפדפן
• נסה לרענן את הדף
• אם אתה במובייל - נסה לפתוח בדפדפן ולא באפליקציה

👇 הנה שוב הקישור לתיאום:
{calendly_link}

📞 אם זה עדיין לא עובד, אתה יכול:
• לשלוח לי הודעה עם התאריכים שנוחים לך
• או לכתוב לי איזה יום ושעה מתאימים לך

אני אדאג שנמצא פתרון! 😊"""
    
    # Helper methods for business logic
    
    def _should_restart_conversation(self, message: str, lead: Dict) -> bool:
        """
        Intelligently decide if we should restart the conversation like a human would.
        A real human agent only restarts when it makes sense contextually.
        """
        message_lower = message.lower().strip()
        current_stage = lead.get('stage', 'new')
        
        # NEVER restart during active conversation stages
        if current_stage in ['new', 'gate_question_payslips', 'gate_question_deposit', 
                           'gate_question_move_date', 'collecting_profile', 'qualified', 
                           'scheduling_in_progress', 'tour_scheduled']:
            return False
        
        # Only restart for failed/ended stages and only with very specific conditions
        if current_stage not in ['gate_failed', 'no_fit', 'future_fit']:
            return False
        
        # Check if this is a pure greeting message (not mixed with other content)
        greeting_only_patterns = [
            r'^(שלום|היי|הלו|hello|hi|hey)\.?!?$',  # Pure greetings only
            r'^(שלום|היי|הלו|hello|hi|hey)\s+(ליאור|lior)\.?!?$',  # Greeting + name
        ]
        
        is_pure_greeting = any(re.match(pattern, message_lower, re.IGNORECASE) for pattern in greeting_only_patterns)
        
        if not is_pure_greeting:
            return False
        
        # Check conversation timing - only restart if it's been a LONG while (2+ hours)
        from datetime import datetime, timedelta
        now = datetime.now()
        last_interaction = lead.get('last_interaction')
        
        if last_interaction:
            try:
                # Parse last interaction time
                if isinstance(last_interaction, str):
                    last_time = datetime.fromisoformat(last_interaction.replace('Z', '+00:00'))
                else:
                    last_time = last_interaction
                
                # Only restart if it's been more than 2 hours
                time_diff = now - last_time.replace(tzinfo=None)
                if time_diff.total_seconds() < 7200:  # 2 hours
                    return False
            except:
                # If we can't parse time, err on the side of not restarting
                return False
        
        # Only restart for pure greetings after a very long break in failed stages
        return True
    
    def _analyze_yes_no_response(self, message: str, context: str = None) -> str:
        """Enhanced analysis of yes/no responses with context awareness"""
        message_lower = message.lower().strip()
        
        # Handle common conversational patterns
        positive_phrases = [
            'ok', 'okay', 'אוקיי', 'בסדר', 'טוב', 'נהדר', 'מצוין', 'בטח', 'ודאי',
            'כן', 'yes', 'יש', 'אכן', 'בוודאי', 'כמובן', 'נכון', 'יפה', 'יופי',
            'אני יכול', 'יש לי', 'i can', 'i have', 'can do', 'אוכל', 'מסוגל',
            'ill pay', 'אני אשלם', 'אשלם', 'משלם', 'אפשר לי', 'יכול לשלם',
            'נתן', 'אתן', 'give', 'provide', 'אספק'
        ]
        
        negative_phrases = [
            'לא יכול', 'אין אפשרות', 'לא ניתן', 'cant', "can't", 'cannot',
            'impossible', 'נמוך', 'קשה', 'בעיה', 'חסר', 'אין באפשרותי',
            'לא', 'no', 'אין', 'אינני', 'איני', 'בלי', 'אין לי', 'אני לא'
        ]
        
        # Context-aware analysis for deposit-related messages
        if context == 'deposit' or any(word in message_lower for word in ['ערבות', 'deposit', 'guarantee', 'pay', 'שלם']):
            # Handle deposit rejection patterns FIRST (more specific)
            if any(phrase in message_lower for phrase in [
                'cant pay', 'לא יכול לשלם', 'אין לי ערבות', 'no deposit', 'אין ערבות',
                'לא אוכל לשלם', 'חסר לי', 'אין באפשרותי', "can't pay", 'cannot pay'
            ]):
                return 'no'
            
            # Then handle deposit acceptance patterns
            if any(phrase in message_lower for phrase in [
                'ok ill pay', 'ill pay it', 'אני אשלם', 'אשלם את זה', 'אתן ערבות',
                'יש לי ערבות', 'can pay', 'יכול לשלם', 'בסדר אשלם', 'אוקיי אשלם'
            ]):
                return 'yes'
        
        # First check for clear negative patterns
        clear_negative_patterns = [
            'לא יכול לשלם', 'אין אפשרות', 'לא ניתן', 'cant pay', "can't pay", 'cannot pay',
            'impossible', 'אין באפשרותי'
        ]
        
        for pattern in clear_negative_patterns:
            if pattern in message_lower:
                return 'no'
        
        # Then check for positive responses
        for phrase in positive_phrases:
            if phrase in message_lower:
                return 'yes'
        
        # Finally check for general negative words (but only if not already caught)
        simple_negatives = ['לא', 'no', 'אין', 'אינני', 'איני', 'בלי', 'אין לי', 'אני לא']
        for phrase in simple_negatives:
            if phrase in message_lower:
                return 'no'
        
        # Check for numeric/specific responses that might indicate agreement
        if context == 'deposit' and re.search(r'\d+.*חודש|month.*\d+', message_lower):
            return 'yes'  # Mentioning specific months usually means agreement
        
        return 'unclear'
    
    def _extract_move_in_days(self, message: str) -> int:
        """Extract move-in timeframe in days using AI"""
        try:
            # Use AI to intelligently parse any move-in date expression
            prompt = f"""
Analyze this message and extract the move-in timeframe in days.

Message: "{message}"

Convert any time expression to the equivalent number of days from today.

Examples:
- "tomorrow" = 1
- "next week" = 7
- "in 2 weeks" = 14
- "in a month" = 30
- "3 months" = 90
- "half a year" = 180
- "מיד" = 1
- "שבוע הבא" = 7
- "חודש" = 30
- "בעוד 20 יום" = 20
- "20 days" = 20
- "in 45 days" = 45

If no clear timeframe is mentioned, return 0.
If the timeframe is vague like "soon" or "when possible", estimate 7 days.

Response format: Only return the number of days as an integer, nothing else.
"""
            
            response = gemini_service.generate_raw_response(prompt)
            
            # Extract number from AI response
            numbers = re.findall(r'\d+', response.strip())
            if numbers:
                return int(numbers[0])
            
            return 0  # Fallback if AI doesn't return a number
            
        except Exception as e:
            logger.error(f"Error extracting move-in days with AI: {e}")
            # Simple fallback: look for any number in the message
            numbers = re.findall(r'\d+', message)
            if numbers:
                return int(numbers[0])
            return 30  # Default fallback
    
    # Removed overly sensitive frustration detection - was causing issues with valid responses

    def _get_missing_profile_info(self, lead: Dict) -> List[str]:
        """Get list of missing profile information in order of collection"""
        missing = []
        
        # Field mapping from database fields to collection field names
        field_mapping = {
            'rooms': 'rooms',
            'budget': 'budget', 
            'has_parking': 'parking',
            'preferred_area': 'area'
        }
        
        collection_order = ['rooms', 'budget', 'parking', 'area']
        
        for field in collection_order:
            db_field = field if field in ['rooms', 'budget'] else {'parking': 'has_parking', 'area': 'preferred_area'}[field]
            
            if lead.get(db_field) is None or (field == 'area' and not lead.get('preferred_area')):
                missing.append(field)
        
        return missing
    
    def _extract_all_profile_data(self, current_message: str, conversation_history: List[Dict], missing_fields: List[str]) -> Dict:
        """Extract all available profile data from current message and conversation history"""
        updates = {}
        
        # Get all user messages from conversation (last 10 messages)
        user_messages = []
        user_messages.append(current_message)  # Current message first
        
        for msg in reversed(conversation_history[-10:]):
            if msg.get('message_type') == 'user':
                user_messages.append(msg.get('content', ''))
        
        # Combine all messages for comprehensive extraction
        all_text = ' '.join(user_messages).lower()
        
        logger.info(f"Extracting profile data from combined text: {all_text[:100]}...")
        
        # Extract rooms (if missing)
        if 'rooms' in missing_fields:
            for msg in user_messages:
                rooms = self._extract_number_from_message(msg)
                if rooms and 1 <= rooms <= 10:
                    # Validate it's about rooms
                    msg_lower = msg.lower()
                    if any(word in msg_lower for word in ['room', 'חדר', 'bedroom', 'bed']):
                        updates['rooms'] = rooms
                        logger.info(f"Extracted rooms: {rooms} from message: {msg[:50]}")
                        break
        
        # Extract budget (if missing)
        if 'budget' in missing_fields:
            for msg in user_messages:
                # Skip messages that are clearly about rooms, not budget
                msg_lower = msg.lower()
                if any(word in msg_lower for word in ['room', 'bedroom', 'חדר']) and not any(word in msg_lower for word in ['budget', 'price', 'cost', 'תקציב', 'מחיר']):
                    continue
                
                budget = self._extract_budget_from_message(msg)
                if budget and budget > 0:
                    # Extra validation for large standalone numbers (likely budget)
                    if budget >= 1000 or any(word in msg_lower for word in ['budget', 'price', 'cost', 'תקציב', 'מחיר', 'thousand', 'אלף']):
                        updates['budget'] = budget
                        logger.info(f"Extracted budget: {budget} from message: {msg[:50]}")
                        break
        
        # Extract parking (if missing)
        if 'parking' in missing_fields:
            for msg in user_messages:
                msg_lower = msg.lower()
                # Look for parking-related keywords
                if any(word in msg_lower for word in ['parking', 'חניה', 'park', 'garage']):
                    parking_response = self._analyze_yes_no_response(msg, context='parking')
                    if parking_response in ['yes', 'no']:
                        updates['has_parking'] = (parking_response == 'yes')
                        logger.info(f"Extracted parking: {parking_response} from message: {msg[:50]}")
                        break
                # Also check for general "yes i need it" after parking question
                elif any(phrase in msg_lower for phrase in ['yes i need it', 'yes i need', 'i need it']):
                    updates['has_parking'] = True
                    logger.info(f"Extracted parking: yes (general affirmation) from message: {msg[:50]}")
                    break
        
        # Extract area (if missing)
        if 'area' in missing_fields:
            for msg in user_messages:
                msg_lower = msg.lower()
                
                # Only skip obvious frustration messages
                if any(phrase in msg_lower for phrase in [
                    'already told you', 'i already told you', 'כבר אמרתי לך'
                ]):
                    continue  # Skip this message
                
                # Look for project-related responses
                if any(phrase in msg_lower for phrase in [
                    'sderot yerushalayim', 'sderot', 'yerushalayim', 'סמטת ירושלים',
                    'neve sharet', 'neve', 'sharet', 'נווה שרת',
                    'afar house', 'afar', 'house', 'אפר האוס',
                    'anywhere', 'any project', 'any place', 'כל מקום', 
                    'לא משנה', 'לא אכפת', 'open to', 'flexible'
                ]) or (len(msg.split()) <= 3 and not any(char.isdigit() for char in msg)):  # Short non-numeric responses
                    area = msg.strip()
                    if len(area) > 1:
                        updates['preferred_area'] = area
                        logger.info(f"Extracted area: {area} from message: {msg[:50]}")
                        break
        
        logger.info(f"Total extracted updates: {updates}")
        return updates
    
    def _extract_profile_data_from_message(self, field: str, message: str) -> Dict:
        """Extract profile data from message based on field type"""
        updates = {}
        
        if field == 'rooms':
            rooms = self._extract_number_from_message(message)
            if rooms and 1 <= rooms <= 10:
                updates['rooms'] = rooms
                
        elif field == 'budget':
            budget = self._extract_budget_from_message(message)
            if budget and budget > 0:
                updates['budget'] = budget
                
        elif field == 'parking':
            parking_response = self._analyze_yes_no_response(message, context='parking')
            if parking_response in ['yes', 'no']:
                updates['has_parking'] = (parking_response == 'yes')
                
        elif field == 'area':
            # Only extract area if it's actually about location preference, not frustration
            message_lower = message.lower()
            
            # Only skip obviously non-location responses
            if any(phrase in message_lower for phrase in [
                'already told you', 'i already told you', 'כבר אמרתי לך'
            ]):
                return updates  # Don't extract area from obvious frustration
            
            # Only extract if it contains project-related keywords or is short project name
            area = message.strip()
            if area and len(area) > 1:
                # Check if it looks like a real project preference
                if any(keyword in message_lower for keyword in [
                    'sderot yerushalayim', 'sderot', 'yerushalayim', 'סמטת ירושלים',
                    'neve sharet', 'neve', 'sharet', 'נווה שרת',
                    'afar house', 'afar', 'house', 'אפר האוס',
                    'anywhere', 'any project', 'any place', 'כל מקום',
                    'לא משנה', 'לא אכפת', 'open to', 'flexible'
                ]) or len(area.split()) <= 3:  # Short responses likely to be project names
                    updates['preferred_area'] = area
        
        return updates
    
    def _extract_number_from_message(self, message: str) -> Optional[int]:
        """Extract number from message"""
        try:
            # Hebrew number words
            hebrew_numbers = {
                'אחד': 1, 'שני': 2, 'שלוש': 3, 'ארבע': 4, 'חמש': 5,
                'שש': 6, 'שבע': 7, 'שמונה': 8, 'תשע': 9, 'עשר': 10,
                'אחת': 1, 'שתיים': 2, 'שלושה': 3, 'ארבעה': 4, 'חמישה': 5
            }
            
            message_lower = message.lower()
            
            # Check for Hebrew number words
            for word, num in hebrew_numbers.items():
                if word in message_lower:
                    return num
            
            # Extract digits
            numbers = re.findall(r'\d+', message)
            if numbers:
                return int(numbers[0])
            
            return None
        except:
            return None
    
    def _extract_budget_from_message(self, message: str) -> Optional[float]:
        """Extract budget from message"""
        try:
            message_lower = message.lower()
            
            # Skip messages that are clearly about time/dates, not budget
            time_indicators = ['day', 'days', 'week', 'weeks', 'month', 'months', 'year', 'years', 
                             'יום', 'ימים', 'שבוע', 'שבועות', 'חודש', 'חודשים', 'שנה', 'שנים',
                             'מחר', 'today', 'tomorrow', 'next', 'הבא', 'בעוד']
            
            if any(indicator in message_lower for indicator in time_indicators):
                return None
            
            # Skip messages that don't have budget-related keywords
            budget_keywords = ['budget', 'price', 'cost', 'pay', 'money', 'afford', 'שכירות',
                             'תקציב', 'מחיר', 'עלות', 'לשלם', 'כסף', 'אלף', 'k', '₪', 'ש"ח']
            
            if not any(keyword in message_lower for keyword in budget_keywords):
                # Only extract if it's a clear standalone number (like "5000")
                numbers = re.findall(r'\b\d{4,5}\b', message)  # Only 4-5 digit numbers
                if numbers:
                    budget = float(numbers[0])
                    if 1000 <= budget <= 50000:
                        return budget
                return None
            
            # Remove commas and extract numbers
            cleaned = re.sub(r'[,\s]', '', message)
            numbers = re.findall(r'\d+', cleaned)
            
            if numbers:
                budget = float(numbers[0])
                
                # Handle different units
                if 'k' in message_lower or 'אלף' in message_lower:
                    budget *= 1000
                elif budget < 100 and any(keyword in message_lower for keyword in budget_keywords):
                    # Only multiply if it's clearly about budget
                    budget *= 1000
                
                # Reasonable budget range (1000-50000 NIS)
                if 1000 <= budget <= 50000:
                    return budget
            
            return None
        except:
            return None
    
    def _search_matching_properties(self, lead: Dict) -> List[Dict]:
        """Search for properties matching lead criteria"""
        try:
            search_criteria = {}
            
            if lead.get('rooms'):
                search_criteria['min_rooms'] = lead['rooms']
                search_criteria['max_rooms'] = lead['rooms']
            
            if lead.get('budget'):
                search_criteria['max_price'] = float(lead['budget'])
            
            if lead.get('has_parking') is not None:
                search_criteria['parking'] = lead['has_parking']
            
            logger.info(f"Searching properties with criteria: {search_criteria}")
            
            units = db_service.get_available_units(search_criteria)
            logger.info(f"Found {len(units)} matching units for lead {lead['id']}")
            
            return units
            
        except Exception as e:
            logger.error(f"Error searching properties for lead {lead['id']}: {e}")
            return []
    
    def _is_property_request(self, message: str) -> bool:
        """Check if message is requesting to see properties"""
        message_lower = message.lower()
        property_keywords = [
            'דירות', 'נכסים', 'אפשרויות', 'מה יש', 'תציג', 'תראה',
            'בוא נראה', 'מצא', 'חפש', 'יש לכם', 'תמונות', 'פרטים'
        ]
        
        for keyword in property_keywords:
            if keyword in message_lower:
                return True
        return False
    
    
    def _ai_suggests_showing_properties(self, ai_response: str) -> bool:
        """Check if AI response suggests showing properties to the user"""
        response_lower = ai_response.lower()
        
        # Look for key phrases that indicate AI wants to show properties
        property_suggestion_phrases = [
            'בוא אראה לך', 'בואו נראה', 'אציג לך', 'תראה לך',
            'יש לי', 'מצאתי', 'אמצא', 
            'let me show you', 'i will show', 'i found', 'let me find'
        ]
        
        for phrase in property_suggestion_phrases:
            if phrase in response_lower:
                return True
        
        return False
    
    def _is_scheduling_request(self, message: str) -> bool:
        """Check if message is requesting to schedule a tour"""
        message_lower = message.lower()
        
        # Strong scheduling indicators (high priority)
        strong_scheduling_phrases = [
            'lets schedule', 'let\'s schedule', 'schedule a tour', 'schedule tour', 
            'schdule', 'schedule', 'schedual',  # Common typos
            'book a tour', 'book tour', 'arrange a tour', 'arrange tour',
            'set up a tour', 'setup a tour', 'plan a tour', 'plan tour',
            'tor', 'toor', 'tour',  # Various spellings of tour
            'לתאם סיור', 'לקבוע סיור', 'סיור', 'בואו נתאם', 'בוא נתאם'
        ]
        
        # Special case: if message contains "lets" or "let's" with schedule-related words
        if ('lets' in message_lower or 'let\'s' in message_lower) and any(word in message_lower for word in ['schedule', 'schdule', 'schedual', 'tour', 'tor', 'toor']):
            return True
        
        for phrase in strong_scheduling_phrases:
            if phrase in message_lower:
                return True
        
        # Check for scheduling-related keywords only if they appear with action words
        scheduling_keywords = [
            # Hebrew 
            'פגישה', 'ביקור', 'לראות', 'לבוא', 'לתאם', 'זמן',
            'מתי', 'אפשר', 'נוח לך', 'תיאום', 'קביעה',
            # English
            'schedule', 'meeting', 'appointment', 'visit', 'tour',
            'meet', 'when', 'time', 'book', 'arrange'
        ]
        
        action_words = [
            'lets', 'let\'s', 'can we', 'want to', 'need to', 'would like',
            'i want', 'we want', 'i need', 'we need', 'בואו', 'בוא', 'אני רוצה',
            'אנחנו רוצים', 'צריך', 'רוצה'
        ]
        
        # Check if message contains both action words and scheduling keywords
        has_action = any(action in message_lower for action in action_words)
        has_scheduling = any(keyword in message_lower for keyword in scheduling_keywords)
        
        if has_action and has_scheduling:
            return True
            
        return False


# Global lead service instance
lead_service = LeadService()