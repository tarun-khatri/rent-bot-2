"""
AI-powered lead management service with strict flow control.
All responses are generated by AI with stage-specific prompts and business rules.
"""

import logging
import os
import re
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
from flask import current_app
from app.services.database_service import db_service
from app.services.gemini_service import gemini_service
from app.config import get_current_time

logger = logging.getLogger(__name__)


class LeadService:
    """AI-powered service for managing lead qualification and conversation flows"""
    
    def __init__(self):
        """Initialize the lead service""" 
        # Removed hardcoded greeting patterns - now using intelligent context-aware detection
    
    def process_lead_message(self, phone_number: str, name: str, message: str) -> str:
        """Main entry point for processing lead messages with AI responses"""
        try:
            logger.info(f"Processing message from {name} ({phone_number}): {message[:50]}...")
            
            # Get or create lead
            lead = db_service.get_lead_by_phone(phone_number)
            if not lead:
                lead = db_service.create_lead(phone_number, name)
                logger.info(f"New lead created: {lead['id']}")
            
            # Check for duplicate message processing (prevent double responses)
            recent_messages = db_service.get_conversation_history(lead['id'], limit=3)
            if recent_messages:
                last_user_message = None
                for msg in reversed(recent_messages):
                    if msg.get('message_type') == 'user':
                        last_user_message = msg.get('content', '').strip()
                        break
                
                # If this is the same message as the last one, don't process again
                if last_user_message and last_user_message == message.strip():
                    logger.info(f"Duplicate message detected for lead {lead['id']}, skipping processing")
                    return "×× ×™ ×›×‘×¨ ×¢×™×‘×“×ª×™ ××ª ×”×”×•×“×¢×” ×”×–×•. ××™×š ×× ×™ ×™×›×•×œ ×œ×¢×–×•×¨ ×œ×š?"
            
            # Log user message
            db_service.log_conversation(lead['id'], 'user', message)
            
            # Check for greeting, but be smart about when to restart (like a human would)
            if self._should_restart_conversation(message, lead):
                logger.info(f"Intelligently restarting conversation for lead {lead['id']} based on context")
                db_service.update_lead(lead['id'], {'stage': 'new'})
                lead = db_service.get_lead_by_phone(phone_number)  # Refresh lead data
            
            # Process based on current stage with AI
            response = self._process_by_stage_with_ai(lead, message)
            
            # Log bot response
            db_service.log_conversation(lead['id'], 'bot', response)
            
            logger.info(f"AI response generated for lead {lead['id']}, length: {len(response)}")
            return response
            
        except Exception as e:
            logger.error(f"Error processing lead message: {e}")
            return "××¦×˜×¢×¨, ×™×© ×œ×™ ×‘×¢×™×” ×˜×›× ×™×ª. ×× × × ×¡×” ×©×•×‘ ×‘×¢×•×“ ×›××” ×“×§×•×ª."
    
    def _process_by_stage_with_ai(self, lead: Dict, message: str) -> str:
        """Process message using AI with intelligent intent understanding"""
        stage = lead.get('stage', 'new')
        
        logger.info(f"Processing AI response for lead {lead['id']} in stage: {stage}")
        
        # Get conversation history for context
        conversation_history = db_service.get_conversation_history(lead['id'], limit=25)
        
        # Use AI to analyze user intent and extract information
        intent_analysis = gemini_service.analyze_user_intent(message, stage, lead)
        logger.info(f"AI intent analysis for lead {lead['id']}: {intent_analysis.get('intent')}")
        
        # Handle different intents intelligently
        if intent_analysis.get('intent') == 'frustration':
            return self._handle_frustration_with_ai(lead, message, conversation_history, intent_analysis)
        
        # Extract and update data from user message
        extracted_data = intent_analysis.get('extracted_data', {})
        if extracted_data:
            self._update_lead_with_extracted_data(lead, extracted_data)
            # Refresh lead data
            lead = db_service.get_lead_by_phone(lead['phone_number'])
        
        # Handle stage transitions based on current stage and intent
        if stage == 'new':
            return self._handle_new_lead_with_ai(lead, message, conversation_history)
        elif stage in ['gate_question_payslips', 'gate_question_deposit', 'gate_question_move_date']:
            return self._handle_gate_questions_with_ai(lead, message, conversation_history, intent_analysis)
        elif stage == 'collecting_profile':
            return self._handle_profile_collection_with_ai(lead, message, conversation_history, intent_analysis)
        elif stage == 'qualified':
            return self._handle_qualified_lead_with_ai(lead, message, conversation_history)
        elif stage == 'scheduling_in_progress':
            return self._handle_scheduling_in_progress_with_ai(lead, message, conversation_history)
        elif stage == 'tour_scheduled':
            return self._handle_tour_scheduled_with_ai(lead, message, conversation_history)
        elif stage in ['gate_failed', 'no_fit', 'future_fit']:
            return self._handle_ended_conversation_with_ai(lead, message, conversation_history)
        else:
            logger.warning(f"Unknown stage for lead {lead['id']}: {stage}")
            return self._handle_unknown_stage_with_ai(lead, message, conversation_history)
    
    def _check_for_qualification_restart(self, lead: Dict, message: str, conversation_history: List[Dict]) -> Optional[str]:
        """
        COMPREHENSIVE EDGE CASE HANDLER
        Checks if user wants to restart qualification process or change previous answers
        """
        stage = lead['stage']
        message_lower = message.lower().strip()
        
        # Edge Case 1: User in failed/ended stage but provides qualification info
        if stage in ['gate_failed', 'no_fit', 'future_fit']:
            logger.info(f"Lead {lead['id']} in failed stage, checking message: '{message_lower}'")
            
            # Check for deposit mentions FIRST (more specific)
            deposit_keywords = ['deposit', 'guarantee', 'month', '×¢×¨×‘×•×ª', '×—×•×“×©', 'pay', 'afford', 'can pay', '××©×œ×', '×™×›×•×œ ×œ×©×œ×']
            found_deposit_keyword = next((kw for kw in deposit_keywords if kw in message_lower), None)
            
            if found_deposit_keyword:
                logger.info(f"Lead {lead['id']} providing deposit info after failed stage - found keyword: '{found_deposit_keyword}'")
                return self._handle_post_failure_deposit_claim(lead, message, conversation_history)
            
            # Check for payslips mentions (but NOT if it's about deposit)
            if any(keyword in message_lower for keyword in ['payslip', 'salary', 'income', '×ª×œ×•×©']) and not any(dep_word in message_lower for dep_word in ['deposit', 'guarantee', '×¢×¨×‘×•×ª']):
                logger.info(f"Lead {lead['id']} providing payslips info after gate_failed - restarting qualification")
                return self._restart_payslips_qualification(lead, message, conversation_history)
            
            # Check for move date changes - be more specific
            move_date_indicators = ['days', 'week', 'soon', 'immediately', '×™×•×', '×©×‘×•×¢', '××™×“', '×‘×§×¨×•×‘']
            if (any(indicator in message_lower for indicator in move_date_indicators) and 
                not is_about_deposit and
                len(message_lower) > 5):  # Avoid single word responses
                logger.info(f"Lead {lead['id']} providing new move date after failed stage")
                return self._handle_post_failure_move_date(lead, message, conversation_history)
        
        # Edge Case 2: User wants to restart entire process
        restart_phrases = ['restart', 'start over', 'begin again', '××—×“×©', '×©×•×‘', '××”×ª×—×œ×”']
        if any(phrase in message_lower for phrase in restart_phrases):
            logger.info(f"Lead {lead['id']} explicitly requesting process restart")
            return self._restart_entire_qualification(lead, conversation_history)
        
        # Edge Case 3: User contradicts previous answer in same conversation - BUT be more lenient
        if stage in ['gate_question_payslips', 'gate_question_deposit', 'gate_question_move_date']:
            contradiction_result = self._check_for_contradictions(lead, message, conversation_history)
            if contradiction_result:
                return contradiction_result
        
        # Edge Case 4: User asking questions instead of answering - handle gracefully
        if self._is_asking_question(message) and stage.startswith('gate_question'):
            logger.info(f"Lead {lead['id']} asking question instead of answering in {stage}")
            return self._handle_user_question(lead, message, conversation_history)
        
        # Edge Case 5: User providing irrelevant information - be less strict
        if self._is_clearly_off_topic(message, stage):
            logger.info(f"Lead {lead['id']} clearly off-topic in stage {stage}")
            return self._redirect_to_current_question(lead, conversation_history)
        
        return None
    
    def _restart_payslips_qualification(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Restart qualification when user claims to have payslips after saying no"""
        logger.info(f"Restarting payslips qualification for lead {lead['id']}")
        
        # Analyze the new payslips claim
        yes_no_response = self._analyze_yes_no_response(message, context='payslips')
        
        if yes_no_response == 'yes':
            # User now claims to have payslips - restart the process
            db_service.update_lead(lead['id'], {
                'stage': 'gate_question_deposit',
                'has_payslips': True
            })
            updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
            return gemini_service.generate_stage_response('gate_question_deposit', updated_lead, conversation_history, message)
        else:
            # Still unclear - ask for clarification
            return gemini_service.generate_stage_response(lead['stage'], lead, conversation_history, message)
    
    def _handle_post_failure_deposit_claim(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle deposit claims after failed qualification with better understanding"""
        logger.info(f"Handling post-failure deposit claim for lead {lead['id']}")
        logger.info(f"Lead status - payslips: {lead.get('has_payslips')}, deposit: {lead.get('can_pay_deposit')}")
        
        # If they already failed on payslips, we need payslips first
        if lead.get('has_payslips') == False:
            logger.info(f"Lead {lead['id']} failed payslips, asking for payslips first")
            return gemini_service.generate_stage_response('gate_failed', lead, conversation_history, 
                "×¢×“×™×™×Ÿ ×¦×¨×™×š ×’× ×ª×œ×•×©×™ ×©×›×¨. ×™×© ×œ×š ×ª×œ×•×©×™ ×©×›×¨ ××”×—×•×“×©×™×™× ×”××—×¨×•× ×™×?")
        
        # Enhanced deposit claim analysis with context
        yes_no_response = self._analyze_yes_no_response(message, context='deposit')
        logger.info(f"Deposit claim analysis for lead {lead['id']}: '{message}' -> '{yes_no_response}'")
        
        # More liberal acceptance of deposit agreement
        if (yes_no_response == 'yes' or 
            any(phrase in message.lower() for phrase in [
                'ok', '××•×§×™×™', '×‘×¡×“×¨', '×˜×•×‘', 'ill pay', '××©×œ×', '×™×›×•×œ ×œ×©×œ×', 
                'can pay', '××ª×Ÿ', '× ×ª×Ÿ', 'provide', '××¡×¤×§'
            ])):
            logger.info(f"Lead {lead['id']} agreed to pay deposit - restarting qualification")
            db_service.update_lead(lead['id'], {
                'stage': 'gate_question_move_date',
                'can_pay_deposit': True
            })
            updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
            return gemini_service.generate_stage_response('gate_question_move_date', updated_lead, conversation_history, message)
        
        # If clearly negative
        if yes_no_response == 'no':
            logger.info(f"Lead {lead['id']} clearly cannot pay deposit - staying failed")
            return gemini_service.generate_stage_response('gate_failed', lead, conversation_history, message)
        
        # If unclear, ask for clarification with empathy
        logger.info(f"Lead {lead['id']} deposit response unclear - asking for clarification")
        clarification_prompt = f"×œ× ×œ×’××¨×™ ×”×‘× ×ª×™. ×”×× ×™×© ×œ×š ×™×›×•×œ×ª ×œ×”×¤×§×™×“ ×¢×¨×‘×•×ª ×©×œ 2 ×—×•×“×©×™ ×©×›×™×¨×•×ª? (×›×Ÿ/×œ×)"
        return gemini_service.generate_stage_response('gate_failed', lead, conversation_history, clarification_prompt)
    
    def _handle_post_failure_move_date(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle move date changes after failed qualification"""
        logger.info(f"Handling post-failure move date for lead {lead['id']}")
        
        # Check if they passed other gate questions first
        if not lead.get('has_payslips') or not lead.get('can_pay_deposit'):
            return gemini_service.generate_stage_response('gate_failed', lead, conversation_history, 
                "×¢×“×™×™×Ÿ ×¦×¨×™×š ×œ×¢×‘×•×¨ ××ª ×›×œ ×‘×“×™×§×•×ª ×”×›×©×¨×•×ª ×§×•×“×.")
        
        # Evaluate new move date
        days_until_move = self._extract_move_in_days(message)
        max_days = current_app.config.get('MAX_MOVE_IN_DAYS', 60)
        
        if days_until_move <= max_days:
            db_service.update_lead(lead['id'], {
                'stage': 'collecting_profile',
                'move_in_date': message.strip()
            })
            updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
            return gemini_service.generate_stage_response('collecting_profile', updated_lead, conversation_history, message)
        
        return gemini_service.generate_stage_response('future_fit', lead, conversation_history, message)
    
    def _restart_entire_qualification(self, lead: Dict, conversation_history: List[Dict]) -> str:
        """Restart the entire qualification process"""
        logger.info(f"Restarting entire qualification for lead {lead['id']}")
        
        # Reset lead to initial state
        db_service.update_lead(lead['id'], {
            'stage': 'gate_question_payslips',
            'has_payslips': None,
            'can_pay_deposit': None,
            'move_in_date': None,
            'rooms': None,
            'budget': None,
            'has_parking': None,
            'preferred_area': None
        })
        
        updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
        return gemini_service.generate_stage_response('gate_question_payslips', updated_lead, conversation_history, "××ª×—×™×œ×™× ××—×“×©")
    
    def _check_for_contradictions(self, lead: Dict, message: str, conversation_history: List[Dict]) -> Optional[str]:
        """Check if current message contradicts previous answers - but only for SAME question type"""
        stage = lead['stage']
        message_lower = message.lower().strip()
        
        # Only check for contradictions in active qualification stages
        if stage not in ['gate_question_payslips', 'gate_question_deposit', 'gate_question_move_date']:
            return None
        
        # Get context for current stage
        current_context = {
            'gate_question_payslips': 'payslips',
            'gate_question_deposit': 'deposit', 
            'gate_question_move_date': 'move_date'
        }.get(stage)
        
        # Check conversation history for previous answers to THE SAME QUESTION TYPE
        try:
            # Only look at the last 2-3 user messages to avoid false positives
            recent_user_messages = [conv for conv in conversation_history[-6:] if conv.get('message_type') == 'user'][-2:]
            
            for conv in reversed(recent_user_messages):
                previous_content = conv.get('content', '').lower()
                
                # Only check contradiction if discussing same topic
                is_same_topic = False
                if current_context == 'payslips' and any(word in previous_content for word in ['×ª×œ×•×©', 'salary', 'payslip']):
                    is_same_topic = True
                elif current_context == 'deposit' and any(word in previous_content for word in ['×¢×¨×‘×•×ª', 'deposit', 'guarantee', 'pay', '×©×œ×']):
                    is_same_topic = True
                elif current_context == 'move_date' and any(word in previous_content for word in ['×™×•×', 'day', 'week', '×©×‘×•×¢', '×—×•×“×©']):
                    is_same_topic = True
                
                if is_same_topic:
                    previous_response = self._analyze_yes_no_response(previous_content, current_context)
                    current_response = self._analyze_yes_no_response(message, current_context)
                    
                    # Only flag as contradiction if CLEARLY opposite responses on SAME topic
                    if (previous_response in ['yes', 'no'] and current_response in ['yes', 'no'] and 
                        previous_response != current_response):
                        logger.info(f"Same-topic contradiction detected for lead {lead['id']}: {previous_response} vs {current_response} on {current_context}")
                        return self._handle_contradiction(lead, message, conversation_history, previous_response, current_response)
                    
        except Exception as e:
            logger.error(f"Error checking for contradictions for lead {lead['id']}: {e}")
            # Continue without contradiction checking if there's an error
        
        return None
    
    def _handle_contradiction(self, lead: Dict, message: str, conversation_history: List[Dict], 
                            previous: str, current: str) -> str:
        """Handle when user gives contradictory answers"""
        logger.info(f"Handling contradiction for lead {lead['id']}: {previous} -> {current}")
        
        # Use the most recent answer and acknowledge the change
        confirmation_message = f"×”×‘× ×ª×™ ×©×”×ª×©×•×‘×” ×©×œ×š ×”×©×ª× ×ª×” ×'{previous}' ×œ'{current}'. × ××©×™×š ×¢× ×”×ª×©×•×‘×” ×”×—×“×©×”."
        
        # Process the new answer based on current stage
        stage = lead['stage']
        if stage == 'gate_question_payslips':
            return self._handle_payslips_with_ai(lead, message, conversation_history)
        elif stage == 'gate_question_deposit':
            return self._handle_deposit_with_ai(lead, message, conversation_history)
        elif stage == 'gate_question_move_date':
            return self._handle_move_date_with_ai(lead, message, conversation_history)
        
        return gemini_service.generate_stage_response(stage, lead, conversation_history, message)
    
    def _is_asking_question(self, message: str) -> bool:
        """Check if user is asking a question instead of answering"""
        message_lower = message.lower().strip()
        
        # Don't treat area responses as questions  
        if any(area_indicator in message_lower for area_indicator in ['anywhere', 'any', '×›×œ', '×œ× ××©× ×”', '×‘×›×œ']):
            return False
            
        question_indicators = [
            '?', 'how much', 'what is', 'when can', 'where is', 'why', 'who',
            '××™×š', '××” ×–×”', '××ª×™ ××¤×©×¨', '××™×¤×” × ××¦×', '×œ××”', '××™', '×›××” ×¢×•×œ×”', '××—×™×¨'
        ]
        return any(indicator in message_lower for indicator in question_indicators)
    
    def _is_clearly_off_topic(self, message: str, stage: str) -> bool:
        """Check if message is CLEARLY off-topic for current stage - be more lenient"""
        message_lower = message.lower().strip()
        
        # During gate questions, only flag as off-topic if it's REALLY unrelated
        if stage.startswith('gate_question'):
            # Only flag as off-topic if discussing complex property details
            clearly_off_topic = [
                'floor plan', 'square meters', 'exact address', 'renovation', 'furniture', 
                '×ª×•×›× ×™×ª ×“×™×¨×”', '××˜×¨×™× ×¨×‘×•×¢×™×', '×›×ª×•×‘×ª ××“×•×™×§×ª', '×©×™×¤×•×¦×™×', '×¨×™×”×•×˜'
            ]
            # Don't flag basic questions about rooms/price as off-topic - they might be clarifying
            return any(keyword in message_lower for keyword in clearly_off_topic)
        
        return False
    
    def _handle_user_question(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle when user asks a question instead of answering"""
        stage = lead['stage']
        
        # Brief answer + redirect to current question
        if stage == 'gate_question_payslips':
            return gemini_service.generate_stage_response(stage, lead, conversation_history, 
                "××¢× ×” ×¢×œ ×–×” ×‘×”××©×š. ×§×•×“× ×›×œ, ×™×© ×œ×š ×ª×œ×•×©×™ ×©×›×¨ ××”×—×•×“×©×™×™× ×”××—×¨×•× ×™×?")
        elif stage == 'gate_question_deposit':
            return gemini_service.generate_stage_response(stage, lead, conversation_history, 
                "× ×“×‘×¨ ×¢×œ ×–×” ××—×¨ ×›×š. ×¢×›×©×™×• ×—×©×•×‘ ×œ×™ ×œ×“×¢×ª - ×™×© ×œ×š ×™×›×•×œ×ª ×œ×”×¤×§×™×“ ×¢×¨×‘×•×ª ×©×œ 2 ×—×•×“×©×™ ×©×›×™×¨×•×ª?")
        elif stage == 'gate_question_move_date':
            return gemini_service.generate_stage_response(stage, lead, conversation_history, 
                "××¢× ×” ×¢×œ ×–×” ×‘×¨×’×¢ ×©× ×¡×™×™×. ××ª×™ ××ª×” ××ª×›× ×Ÿ ×œ×”×™×›× ×¡ ×œ×“×™×¨×”?")
        else:
            return gemini_service.generate_stage_response(stage, lead, conversation_history, message)
    
    def _redirect_to_current_question(self, lead: Dict, conversation_history: List[Dict]) -> str:
        """Redirect user back to current stage question"""
        stage = lead['stage']
        
        if stage == 'gate_question_payslips':
            redirect_message = "×‘×•××• × ×ª××§×“ ×§×•×“× ×‘×‘×“×™×§×•×ª ×”×›×©×¨×•×ª. ×™×© ×œ×š ×ª×œ×•×©×™ ×©×›×¨ ××”×—×•×“×©×™×™× ×”××—×¨×•× ×™×?"
        elif stage == 'gate_question_deposit':
            redirect_message = "× ×“×‘×¨ ×¢×œ ×–×” ××—×¨ ×›×š. ×¢×›×©×™×• ×× ×™ ×¦×¨×™×š ×œ×“×¢×ª - ×™×© ×œ×š ×™×›×•×œ×ª ×œ×”×¤×§×™×“ ×¢×¨×‘×•×ª ×©×œ 2 ×—×•×“×©×™ ×©×›×™×¨×•×ª?"
        elif stage == 'gate_question_move_date':
            redirect_message = "××ª×™ ××ª×” ××ª×›× ×Ÿ ×œ×”×™×›× ×¡ ×œ×“×™×¨×”?"
        else:
            redirect_message = "×‘×•××• × ××©×™×š ×¢× ×”×ª×”×œ×™×š ×”×©×œ×‘ ××—×¨ ×©×œ×‘"
        
        return gemini_service.generate_stage_response(stage, lead, conversation_history, redirect_message)
    
    def _update_lead_with_extracted_data(self, lead: Dict, extracted_data: Dict) -> None:
        """Update lead with data extracted by AI"""
        updates = {}
        
        # Map extracted data to database fields
        if extracted_data.get('has_payslips') is not None:
            updates['has_payslips'] = extracted_data['has_payslips']
        if extracted_data.get('can_pay_deposit') is not None:
            updates['can_pay_deposit'] = extracted_data['can_pay_deposit']
        if extracted_data.get('move_in_date'):
            updates['move_in_date'] = extracted_data['move_in_date']
        if extracted_data.get('rooms'):
            updates['rooms'] = extracted_data['rooms']
        if extracted_data.get('budget'):
            updates['budget'] = extracted_data['budget']
        if extracted_data.get('has_parking') is not None:
            updates['has_parking'] = extracted_data['has_parking']
        if extracted_data.get('preferred_project'):
            updates['preferred_area'] = extracted_data['preferred_project']
        if extracted_data.get('preferred_floor_min'):
            updates['preferred_floor_min'] = extracted_data['preferred_floor_min']
        if extracted_data.get('preferred_floor_max'):
            updates['preferred_floor_max'] = extracted_data['preferred_floor_max']
        if extracted_data.get('needs_furnished') is not None:
            updates['needs_furnished'] = extracted_data['needs_furnished']
        if extracted_data.get('pet_owner') is not None:
            updates['pet_owner'] = extracted_data['pet_owner']
        if extracted_data.get('email'):
            updates['email'] = extracted_data['email']
        
        if updates:
            db_service.update_lead(lead['id'], updates)
            logger.info(f"Updated lead {lead['id']} with extracted data: {updates}")

    def _handle_frustration_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict], intent_analysis: Dict) -> str:
        """Handle frustrated users with empathy and AI understanding"""
        logger.info(f"Handling frustration for lead {lead['id']}")
        
        # Use AI to generate empathetic response
        return gemini_service.generate_stage_response('frustration', lead, conversation_history, message)

    def _handle_gate_questions_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict], intent_analysis: Dict) -> str:
        """Handle gate questions using AI intent understanding"""
        stage = lead['stage']
        logger.info(f"Handling gate question {stage} for lead {lead['id']} with AI")
        
        # Check if we have clear answers from AI analysis
        extracted_data = intent_analysis.get('extracted_data', {})
        
        if stage == 'gate_question_payslips':
            if extracted_data.get('has_payslips') is not None:
                if extracted_data['has_payslips']:
                    # Passed payslips gate
                    db_service.update_lead(lead['id'], {
                        'stage': 'gate_question_deposit',
                        'has_payslips': True
                    })
                    updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
                    return gemini_service.generate_stage_response('gate_question_deposit', updated_lead, conversation_history, message)
                else:
                    # Failed payslips gate
                    db_service.update_lead(lead['id'], {
                        'stage': 'gate_failed',
                        'has_payslips': False
                    })
                    updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
                    return gemini_service.generate_stage_response('gate_failed', updated_lead, conversation_history, message)
        
        elif stage == 'gate_question_deposit':
            if extracted_data.get('can_pay_deposit') is not None:
                if extracted_data['can_pay_deposit']:
                    # Passed deposit gate
                    db_service.update_lead(lead['id'], {
                        'stage': 'gate_question_move_date',
                        'can_pay_deposit': True
                    })
                    updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
                    return gemini_service.generate_stage_response('gate_question_move_date', updated_lead, conversation_history, message)
                else:
                    # Failed deposit gate
                    db_service.update_lead(lead['id'], {
                        'stage': 'gate_failed',
                        'can_pay_deposit': False
                    })
                    updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
                    return gemini_service.generate_stage_response('gate_failed', updated_lead, conversation_history, message)
        
        elif stage == 'gate_question_move_date':
            if extracted_data.get('move_in_date'):
                # Check if move-in date is acceptable
                days_until_move = self._extract_move_in_days(extracted_data['move_in_date'])
                max_days = current_app.config.get('MAX_MOVE_IN_DAYS', 60)
                
                if days_until_move <= max_days:
                    # Good move-in date
                    db_service.update_lead(lead['id'], {
                        'stage': 'collecting_profile',
                        'move_in_date': extracted_data['move_in_date']
                    })
                    updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
                    return gemini_service.generate_stage_response('collecting_profile', updated_lead, conversation_history, message)
                else:
                    # Too far in future
                    db_service.update_lead(lead['id'], {
                        'stage': 'future_fit',
                        'move_in_date': extracted_data['move_in_date']
                    })
                    updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
                    return gemini_service.generate_stage_response('future_fit', updated_lead, conversation_history, message)
        
        # If AI needs clarification, ask for it
        if intent_analysis.get('needs_clarification'):
            clarification_question = intent_analysis.get('clarification_question')
            if clarification_question:
                return clarification_question
        
        # Default to AI-generated response for the current stage
        return gemini_service.generate_stage_response(stage, lead, conversation_history, message)

    def _handle_new_lead_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle new lead with AI-generated welcome and first gate question"""
        logger.info(f"Handling new lead {lead['id']} with AI")
        
        # Update stage to first gate question
        db_service.update_lead(lead['id'], {'stage': 'gate_question_payslips'})
        
        # Get AI response for new lead welcome
        return gemini_service.generate_stage_response('new', lead, conversation_history, message)
    
    
    def _handle_profile_collection_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict], intent_analysis: Dict = None) -> str:
        """Handle profile collection with AI intent understanding"""
        logger.info(f"Collecting profile info for lead {lead['id']} with AI")
        
        # Check what profile information is missing
        missing_info = self._get_missing_profile_info(lead)
        
        if not missing_info:
            # Profile is complete, search for properties
            return self._complete_profile_and_search_with_ai(lead, conversation_history)
        
        # If AI needs clarification, ask for it
        if intent_analysis and intent_analysis.get('needs_clarification'):
            clarification_question = intent_analysis.get('clarification_question')
            if clarification_question:
                return clarification_question
        
        # Get updated lead data for AI context
        current_lead = db_service.get_lead_by_phone(lead['phone_number'])
        return gemini_service.generate_stage_response('collecting_profile', current_lead, conversation_history, message)
    
    def _handle_qualified_lead_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle qualified lead with AI responses"""
        logger.info(f"Handling qualified lead {lead['id']} with AI")
        
        # Check if they want to schedule a tour (HIGHEST PRIORITY)
        if self._is_scheduling_request(message):
            return self._handle_scheduling_request_with_ai(lead, message, conversation_history)
        
        # Check if they're asking for property recommendations
        if self._is_property_request(message):
            return self._search_and_present_properties_with_ai(lead, conversation_history)
        
        # For qualified leads, let AI decide if they should see properties
        # The AI will be instructed to offer properties proactively
        ai_response = gemini_service.generate_stage_response('qualified', lead, conversation_history, message)
        
        # If AI suggests showing properties, do it (but only if not scheduling)
        if self._ai_suggests_showing_properties(ai_response) and not self._is_scheduling_request(message):
            logger.info(f"AI suggested showing properties to lead {lead['id']}")
            return self._search_and_present_properties_with_ai(lead, conversation_history)
        
        return ai_response
    
    def _handle_scheduling_in_progress_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle lead who is in the process of scheduling a tour"""
        logger.info(f"Handling scheduling in progress for lead {lead['id']} with AI")
        
        # Check if they're confirming they booked an appointment
        if self._is_booking_confirmation(message):
            logger.info(f"Lead {lead['id']} confirmed booking - moving to tour_scheduled")
            db_service.update_lead(lead['id'], {'stage': 'tour_scheduled'})
            updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
            return self._generate_booking_confirmation_message()
        
        # Check if they need help with the Calendly link
        if self._is_calendly_help_request(message):
            logger.info(f"Lead {lead['id']} needs help with Calendly")
            calendly_link = os.getenv('CALENDLY_LINK')
            return self._generate_calendly_help_message(calendly_link)
        
        # Check if they want to go back to seeing more properties
        if self._is_property_request(message):
            logger.info(f"Lead {lead['id']} wants to see more properties before scheduling")
            db_service.update_lead(lead['id'], {'stage': 'qualified'})
            updated_lead = db_service.get_lead_by_phone(lead['phone_number'])
            return self._search_and_present_properties_with_ai(updated_lead, conversation_history)
        
        # General response for scheduling stage
        return gemini_service.generate_stage_response('scheduling_in_progress', lead, conversation_history, message)
    
    def _handle_tour_scheduled_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle tour scheduled lead with AI"""
        logger.info(f"Handling tour scheduled lead {lead['id']} with AI")
        return gemini_service.generate_stage_response('tour_scheduled', lead, conversation_history, message)
    
    def _handle_ended_conversation_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle ended conversations with AI"""
        stage = lead.get('stage')
        logger.info(f"Handling ended conversation for lead {lead['id']} in stage {stage} with AI")
        return gemini_service.generate_stage_response(stage, lead, conversation_history, message)
    
    def _handle_unknown_stage_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle unknown stage with AI"""
        logger.warning(f"Unknown stage for lead {lead['id']}: {lead.get('stage')}")
        # Default to qualified stage for unknown stages
        return gemini_service.generate_stage_response('qualified', lead, conversation_history, message)
    
    def _complete_profile_and_search_with_ai(self, lead: Dict, conversation_history: List[Dict]) -> str:
        """Complete profile collection and search for properties with AI"""
        logger.info(f"Profile complete for lead {lead['id']}, searching properties with AI")
        
        # Update stage to qualified
        db_service.update_lead(lead['id'], {'stage': 'qualified'})
        
        # Search for matching properties
        units = self._search_matching_properties(lead)
        
        if units:
            # Found matching properties, generate AI recommendation and send images
            ai_response = gemini_service.generate_property_recommendation(lead, units)
            
            # Send property images after AI text response
            try:
                from app.services.messaging_service import messaging_service
                messaging_service.send_property_images(lead['id'], units)
                logger.info(f"Property images sent to lead {lead['id']}")
            except Exception as e:
                logger.error(f"Failed to send property images to lead {lead['id']}: {e}")
            
            return ai_response
        else:
            # No matching properties, generate AI response for alternatives
            return gemini_service.generate_no_properties_response(lead, conversation_history)
    
    def _search_and_present_properties_with_ai(self, lead: Dict, conversation_history: List[Dict]) -> str:
        """Search and present properties with AI"""
        logger.info(f"Searching properties for qualified lead {lead['id']} with AI")
        
        units = self._search_matching_properties(lead)
        
        if units:
            # Generate AI recommendation and send images
            ai_response = gemini_service.generate_property_recommendation(lead, units)
            
            # Send property images after AI text response
            try:
                from app.services.messaging_service import messaging_service
                messaging_service.send_property_images(lead['id'], units)
                logger.info(f"Property images sent to qualified lead {lead['id']}")
            except Exception as e:
                logger.error(f"Failed to send property images to qualified lead {lead['id']}: {e}")
            
            return ai_response
        else:
            return gemini_service.generate_no_properties_response(lead, conversation_history)
    
    def _handle_scheduling_request_with_ai(self, lead: Dict, message: str, conversation_history: List[Dict]) -> str:
        """Handle scheduling request with AI"""
        logger.info(f"Handling scheduling request for lead {lead['id']} with AI")
        
        # Get Calendly link from environment with fallback
        calendly_link = os.getenv('CALENDLY_LINK')
        
        if not calendly_link:
            logger.warning("No CALENDLY_LINK configured in environment, using manual scheduling")
            # Update stage to scheduling in progress
            db_service.update_lead(lead['id'], {'stage': 'scheduling_in_progress'})
            return self._generate_manual_scheduling_message()
        
        # Update stage to scheduling in progress
        db_service.update_lead(lead['id'], {'stage': 'scheduling_in_progress'})
        
        # Generate scheduling message with Calendly link
        return self._generate_calendly_message(calendly_link)
    
    def _generate_calendly_message(self, calendly_link: str) -> str:
        """Generate scheduling message with Calendly link and confirmation instructions"""
        return f"""ğŸ‰ ××¢×•×œ×”! ×‘×•××• × ×ª×× ×¤×’×™×©×” ×œ×¦×¤×™×™×” ×‘×“×™×¨×•×ª!

ğŸ‘‡ ×œ×—×¥ ×¢×œ ×”×§×™×©×•×¨ ×”×–×” ×œ×‘×—×™×¨×ª ×”×ª××¨×™×š ×•×”×©×¢×” ×©× ×•×—×™× ×œ×š:

{calendly_link}

ğŸ“ ××—×¨×™ ×©×ª×–××™×Ÿ ×¤×’×™×©×” ×‘×§×œ× ×“×œ×™, ×× × ×—×–×•×¨ ×œ×›××Ÿ ×•××©×¨ ×œ×™ ×©×§×‘×¢×ª - ×›×“×™ ×©××•×›×œ ×œ×”×›×™×Ÿ ××ª ×›×œ ×”×¤×¨×˜×™× ×¢×‘×•×¨×š!

â° ×”×¤×’×™×©×” ×ª×§×— ×‘×¢×¨×š 30-45 ×“×§×•×ª, ×•×× ×™ ××œ×•×•×” ××•×ª×š ×œ×¨××•×ª ××ª ×”×“×™×¨×•×ª ×©×”×›×™ ××ª××™××•×ª ×œ×ª×§×¦×™×‘ ×•×œ×“×¨×™×©×•×ª ×©×œ×š.

ğŸ’¡ ×˜×™×¤: ××•××œ×¥ ×œ×§×‘×•×¢ ×œ×¤×—×•×ª ×™×•× ××¨××© ×›×“×™ ×©××•×›×œ ×œ×”×›×™×Ÿ ×¢×‘×•×¨×š ××ª ×”×“×™×¨×•×ª ×”×˜×•×‘×•×ª ×‘×™×•×ª×¨!

×™×© ×œ×š ×©××œ×•×ª × ×•×¡×¤×•×ª? ×× ×™ ×›××Ÿ ×œ×¢×–×•×¨! ğŸ˜Š"""
    
    def _generate_manual_scheduling_message(self) -> str:
        """Generate manual scheduling message when Calendly is not available"""
        return """ğŸ‰ ××¢×•×œ×”! ×‘×•××• × ×ª×× ×¤×’×™×©×” ×œ×¦×¤×™×™×” ×‘×“×™×¨×•×ª!

ğŸ“… ×× ×™ ××ª×× ××™×ª×š ×¤×’×™×©×” ×‘××•×¤×Ÿ ××™×©×™.

â° ×× × ×¡×¤×¨ ×œ×™ ××ª×™ × ×•×— ×œ×š:
â€¢ ××™×–×” ×™×•× ××”×©×‘×•×¢ ×”×‘×?
â€¢ ××™×–×” ×©×¢×” ××•×¢×“×¤×ª ×¢×œ×™×š? (×‘×•×§×¨/×¦×”×¨×™×™×/××—×¨ ×”×¦×”×¨×™×™×)

ğŸ“ ×”×¤×’×™×©×” ×ª×§×— ×‘×¢×¨×š 30-45 ×“×§×•×ª, ×•×× ×™ ××œ×•×•×” ××•×ª×š ×œ×¨××•×ª ××ª ×”×“×™×¨×•×ª ×©×”×›×™ ××ª××™××•×ª ×œ×ª×§×¦×™×‘ ×•×œ×“×¨×™×©×•×ª ×©×œ×š.

ğŸ’¡ ×× ×™ ××›×™×Ÿ ×¢×‘×•×¨×š ××¨××© ××ª ×”×“×™×¨×•×ª ×”×˜×•×‘×•×ª ×‘×™×•×ª×¨!

×›×ª×•×‘ ×œ×™ ××ª ×”×–××Ÿ ×©× ×•×— ×œ×š ×•×× ×™ ××¡×“×¨ ×”×›×œ! ğŸ˜Š"""
    
    def _is_booking_confirmation(self, message: str) -> bool:
        """Check if message is confirming that they booked an appointment"""
        message_lower = message.lower().strip()
        
        confirmation_phrases = [
            '×§×‘×¢×ª×™', '×”×–×× ×ª×™', '×ª×™×××ª×™', '×¨×©××ª×™',
            'booked', 'scheduled', 'confirmed', 'set',
            '×§×™×‘×œ×ª×™ ××™×©×•×¨', '× ×§×‘×¢', '×–×•××Ÿ', '×¢×©×™×ª×™', '×¡×™×“×¨×ª×™',
            'done', 'finished', 'completed'
        ]
        
        for phrase in confirmation_phrases:
            if phrase in message_lower:
                return True
        
        return False
    
    def _is_calendly_help_request(self, message: str) -> bool:
        """Check if they need help with the Calendly booking process"""
        message_lower = message.lower().strip()
        
        help_phrases = [
            '×œ× ×¢×•×‘×“', '×‘×¢×™×”', '×¢×–×¨×”', '×œ× ××¦×œ×™×—', '×œ× ×™×›×•×œ',
            'not working', 'help', 'problem', 'issue', 'error',
            '×›×©×œ', '×ª×§×œ×”', '×œ× ×¤×•×ª×—', '×œ× × ×˜×¢×Ÿ',
            'cant', "can't", 'cannot', 'broken', 'stuck'
        ]
        
        for phrase in help_phrases:
            if phrase in message_lower:
                return True
        
        return False
    
    def _generate_booking_confirmation_message(self) -> str:
        """Generate message confirming that appointment was booked"""
        return """ğŸ‰ ××¢×•×œ×”! ×§×™×‘×œ×ª×™ ××ª ×”××™×©×•×¨ ×©×§×‘×¢×ª ×¤×’×™×©×”!

âœ… ×× ×™ ××›×™×Ÿ ×¢×‘×•×¨×š ××ª ×›×œ ×”×¤×¨×˜×™× ×œ×¤×’×™×©×” ×•××©×œ×— ×œ×š ×ª×–×›×•×¨×•×ª ×œ×¤× ×™ ×”××•×¢×“.

ğŸ“‹ ×‘××”×œ×š ×”×¤×’×™×©×” × ×¨××” ×‘×™×—×“:
â€¢ ××ª ×”×“×™×¨×•×ª ×©×”×›×™ ××ª××™××•×ª ×œ×ª×§×¦×™×‘ ×©×œ×š
â€¢ × ×‘×“×•×§ ××ª ×”××™×§×•× ×•×”×¡×‘×™×‘×”
â€¢ × ×¢×‘×•×¨ ×¢×œ ×›×œ ×”×¤×¨×˜×™× ×”×—×©×•×‘×™×

ğŸ“ ×× ×™×© ×œ×š ×©××œ×•×ª × ×•×¡×¤×•×ª ×œ×¤× ×™ ×”×¤×’×™×©×” - ×× ×™ ×›××Ÿ!

××—×›×” ×œ×¤×’×•×© ××•×ª×š! ğŸ˜Š"""
    
    def _generate_calendly_help_message(self, calendly_link: str) -> str:
        """Generate help message when user has issues with Calendly"""
        return f"""ğŸ˜” ××¦×˜×¢×¨ ×©×™×© ×‘×¢×™×”! ×‘×•××• × × ×¡×” ×©×•×‘:

ğŸ”§ ×“×‘×¨×™× ×œ×‘×“×•×§:
â€¢ ×•×“× ×©×”×§×™×©×•×¨ × ×¤×ª×— ×‘×“×¤×“×¤×Ÿ
â€¢ × ×¡×” ×œ×¨×¢× ×Ÿ ××ª ×”×“×£
â€¢ ×× ××ª×” ×‘××•×‘×™×™×œ - × ×¡×” ×œ×¤×ª×•×— ×‘×“×¤×“×¤×Ÿ ×•×œ× ×‘××¤×œ×™×§×¦×™×”

ğŸ‘‡ ×”× ×” ×©×•×‘ ×”×§×™×©×•×¨ ×œ×ª×™××•×:
{calendly_link}

ğŸ“ ×× ×–×” ×¢×“×™×™×Ÿ ×œ× ×¢×•×‘×“, ××ª×” ×™×›×•×œ:
â€¢ ×œ×©×œ×•×— ×œ×™ ×”×•×“×¢×” ×¢× ×”×ª××¨×™×›×™× ×©× ×•×—×™× ×œ×š
â€¢ ××• ×œ×›×ª×•×‘ ×œ×™ ××™×–×” ×™×•× ×•×©×¢×” ××ª××™××™× ×œ×š

×× ×™ ××“××’ ×©× ××¦× ×¤×ª×¨×•×Ÿ! ğŸ˜Š"""
    
    # Helper methods for business logic
    
    def _should_restart_conversation(self, message: str, lead: Dict) -> bool:
        """
        Intelligently decide if we should restart the conversation like a human would.
        A real human agent only restarts when it makes sense contextually.
        """
        message_lower = message.lower().strip()
        current_stage = lead.get('stage', 'new')
        
        # NEVER restart during active conversation stages
        if current_stage in ['new', 'gate_question_payslips', 'gate_question_deposit', 
                           'gate_question_move_date', 'collecting_profile', 'qualified', 
                           'scheduling_in_progress', 'tour_scheduled']:
            return False
        
        # Only restart for failed/ended stages and only with very specific conditions
        if current_stage not in ['gate_failed', 'no_fit', 'future_fit']:
            return False
        
        # Check if this is a pure greeting message (not mixed with other content)
        greeting_only_patterns = [
            r'^(×©×œ×•×|×”×™×™|×”×œ×•|hello|hi|hey)\.?!?$',  # Pure greetings only
            r'^(×©×œ×•×|×”×™×™|×”×œ×•|hello|hi|hey)\s+(×œ×™××•×¨|lior)\.?!?$',  # Greeting + name
        ]
        
        is_pure_greeting = any(re.match(pattern, message_lower, re.IGNORECASE) for pattern in greeting_only_patterns)
        
        if not is_pure_greeting:
            return False
        
        # Check conversation timing - only restart if it's been a LONG while (2+ hours)
        from datetime import datetime, timedelta
        now = datetime.now()
        last_interaction = lead.get('last_interaction')
        
        if last_interaction:
            try:
                # Parse last interaction time
                if isinstance(last_interaction, str):
                    last_time = datetime.fromisoformat(last_interaction.replace('Z', '+00:00'))
                else:
                    last_time = last_interaction
                
                # Only restart if it's been more than 2 hours
                time_diff = now - last_time.replace(tzinfo=None)
                if time_diff.total_seconds() < 7200:  # 2 hours
                    return False
            except:
                # If we can't parse time, err on the side of not restarting
                return False
        
        # Only restart for pure greetings after a very long break in failed stages
        return True
    
    def _analyze_yes_no_response(self, message: str, context: str = None) -> str:
        """Enhanced analysis of yes/no responses with context awareness"""
        message_lower = message.lower().strip()
        
        # Handle common conversational patterns
        positive_phrases = [
            'ok', 'okay', '××•×§×™×™', '×‘×¡×“×¨', '×˜×•×‘', '× ×”×“×¨', '××¦×•×™×Ÿ', '×‘×˜×—', '×•×“××™',
            '×›×Ÿ', 'yes', '×™×©', '××›×Ÿ', '×‘×•×•×“××™', '×›××•×‘×Ÿ', '× ×›×•×Ÿ', '×™×¤×”', '×™×•×¤×™',
            '×× ×™ ×™×›×•×œ', '×™×© ×œ×™', 'i can', 'i have', 'can do', '××•×›×œ', '××¡×•×’×œ',
            'ill pay', '×× ×™ ××©×œ×', '××©×œ×', '××©×œ×', '××¤×©×¨ ×œ×™', '×™×›×•×œ ×œ×©×œ×',
            '× ×ª×Ÿ', '××ª×Ÿ', 'give', 'provide', '××¡×¤×§'
        ]
        
        negative_phrases = [
            '×œ× ×™×›×•×œ', '××™×Ÿ ××¤×©×¨×•×ª', '×œ× × ×™×ª×Ÿ', 'cant', "can't", 'cannot',
            'impossible', '× ××•×š', '×§×©×”', '×‘×¢×™×”', '×—×¡×¨', '××™×Ÿ ×‘××¤×©×¨×•×ª×™',
            '×œ×', 'no', '××™×Ÿ', '××™× × ×™', '××™× ×™', '×‘×œ×™', '××™×Ÿ ×œ×™', '×× ×™ ×œ×'
        ]
        
        # Context-aware analysis for deposit-related messages
        if context == 'deposit' or any(word in message_lower for word in ['×¢×¨×‘×•×ª', 'deposit', 'guarantee', 'pay', '×©×œ×']):
            # Handle deposit rejection patterns FIRST (more specific)
            if any(phrase in message_lower for phrase in [
                'cant pay', '×œ× ×™×›×•×œ ×œ×©×œ×', '××™×Ÿ ×œ×™ ×¢×¨×‘×•×ª', 'no deposit', '××™×Ÿ ×¢×¨×‘×•×ª',
                '×œ× ××•×›×œ ×œ×©×œ×', '×—×¡×¨ ×œ×™', '××™×Ÿ ×‘××¤×©×¨×•×ª×™', "can't pay", 'cannot pay'
            ]):
                return 'no'
            
            # Then handle deposit acceptance patterns
            if any(phrase in message_lower for phrase in [
                'ok ill pay', 'ill pay it', '×× ×™ ××©×œ×', '××©×œ× ××ª ×–×”', '××ª×Ÿ ×¢×¨×‘×•×ª',
                '×™×© ×œ×™ ×¢×¨×‘×•×ª', 'can pay', '×™×›×•×œ ×œ×©×œ×', '×‘×¡×“×¨ ××©×œ×', '××•×§×™×™ ××©×œ×'
            ]):
                return 'yes'
        
        # First check for clear negative patterns
        clear_negative_patterns = [
            '×œ× ×™×›×•×œ ×œ×©×œ×', '××™×Ÿ ××¤×©×¨×•×ª', '×œ× × ×™×ª×Ÿ', 'cant pay', "can't pay", 'cannot pay',
            'impossible', '××™×Ÿ ×‘××¤×©×¨×•×ª×™'
        ]
        
        for pattern in clear_negative_patterns:
            if pattern in message_lower:
                return 'no'
        
        # Then check for positive responses
        for phrase in positive_phrases:
            if phrase in message_lower:
                return 'yes'
        
        # Finally check for general negative words (but only if not already caught)
        simple_negatives = ['×œ×', 'no', '××™×Ÿ', '××™× × ×™', '××™× ×™', '×‘×œ×™', '××™×Ÿ ×œ×™', '×× ×™ ×œ×']
        for phrase in simple_negatives:
            if phrase in message_lower:
                return 'no'
        
        # Check for numeric/specific responses that might indicate agreement
        if context == 'deposit' and re.search(r'\d+.*×—×•×“×©|month.*\d+', message_lower):
            return 'yes'  # Mentioning specific months usually means agreement
        
        return 'unclear'
    
    def _extract_move_in_days(self, message: str) -> int:
        """Extract move-in timeframe in days using AI"""
        try:
            # Use AI to intelligently parse any move-in date expression
            prompt = f"""
Analyze this message and extract the move-in timeframe in days.

Message: "{message}"

Convert any time expression to the equivalent number of days from today.

Examples:
- "tomorrow" = 1
- "next week" = 7
- "in 2 weeks" = 14
- "in a month" = 30
- "3 months" = 90
- "half a year" = 180
- "××™×“" = 1
- "×©×‘×•×¢ ×”×‘×" = 7
- "×—×•×“×©" = 30
- "×‘×¢×•×“ 20 ×™×•×" = 20
- "20 days" = 20
- "in 45 days" = 45

If no clear timeframe is mentioned, return 0.
If the timeframe is vague like "soon" or "when possible", estimate 7 days.

Response format: Only return the number of days as an integer, nothing else.
"""
            
            response = gemini_service.generate_raw_response(prompt)
            
            # Extract number from AI response
            numbers = re.findall(r'\d+', response.strip())
            if numbers:
                return int(numbers[0])
            
            return 0  # Fallback if AI doesn't return a number
            
        except Exception as e:
            logger.error(f"Error extracting move-in days with AI: {e}")
            # Simple fallback: look for any number in the message
            numbers = re.findall(r'\d+', message)
            if numbers:
                return int(numbers[0])
            return 30  # Default fallback
    
    # Removed overly sensitive frustration detection - was causing issues with valid responses

    def _get_missing_profile_info(self, lead: Dict) -> List[str]:
        """Get list of missing profile information in order of collection"""
        missing = []
        
        # Field mapping from database fields to collection field names
        field_mapping = {
            'rooms': 'rooms',
            'budget': 'budget', 
            'has_parking': 'parking',
            'preferred_area': 'area'
        }
        
        collection_order = ['rooms', 'budget', 'parking', 'area']
        
        for field in collection_order:
            db_field = field if field in ['rooms', 'budget'] else {'parking': 'has_parking', 'area': 'preferred_area'}[field]
            
            if lead.get(db_field) is None or (field == 'area' and not lead.get('preferred_area')):
                missing.append(field)
        
        return missing
    
    def _extract_all_profile_data(self, current_message: str, conversation_history: List[Dict], missing_fields: List[str]) -> Dict:
        """Extract all available profile data from current message and conversation history"""
        updates = {}
        
        # Get all user messages from conversation (last 10 messages)
        user_messages = []
        user_messages.append(current_message)  # Current message first
        
        for msg in reversed(conversation_history[-10:]):
            if msg.get('message_type') == 'user':
                user_messages.append(msg.get('content', ''))
        
        # Combine all messages for comprehensive extraction
        all_text = ' '.join(user_messages).lower()
        
        logger.info(f"Extracting profile data from combined text: {all_text[:100]}...")
        
        # Extract rooms (if missing)
        if 'rooms' in missing_fields:
            for msg in user_messages:
                rooms = self._extract_number_from_message(msg)
                if rooms and 1 <= rooms <= 10:
                    # Validate it's about rooms
                    msg_lower = msg.lower()
                    if any(word in msg_lower for word in ['room', '×—×“×¨', 'bedroom', 'bed']):
                        updates['rooms'] = rooms
                        logger.info(f"Extracted rooms: {rooms} from message: {msg[:50]}")
                        break
        
        # Extract budget (if missing)
        if 'budget' in missing_fields:
            for msg in user_messages:
                # Skip messages that are clearly about rooms, not budget
                msg_lower = msg.lower()
                if any(word in msg_lower for word in ['room', 'bedroom', '×—×“×¨']) and not any(word in msg_lower for word in ['budget', 'price', 'cost', '×ª×§×¦×™×‘', '××—×™×¨']):
                    continue
                
                budget = self._extract_budget_from_message(msg)
                if budget and budget > 0:
                    # Extra validation for large standalone numbers (likely budget)
                    if budget >= 1000 or any(word in msg_lower for word in ['budget', 'price', 'cost', '×ª×§×¦×™×‘', '××—×™×¨', 'thousand', '××œ×£']):
                        updates['budget'] = budget
                        logger.info(f"Extracted budget: {budget} from message: {msg[:50]}")
                        break
        
        # Extract parking (if missing)
        if 'parking' in missing_fields:
            for msg in user_messages:
                msg_lower = msg.lower()
                # Look for parking-related keywords
                if any(word in msg_lower for word in ['parking', '×—× ×™×”', 'park', 'garage']):
                    parking_response = self._analyze_yes_no_response(msg, context='parking')
                    if parking_response in ['yes', 'no']:
                        updates['has_parking'] = (parking_response == 'yes')
                        logger.info(f"Extracted parking: {parking_response} from message: {msg[:50]}")
                        break
                # Also check for general "yes i need it" after parking question
                elif any(phrase in msg_lower for phrase in ['yes i need it', 'yes i need', 'i need it']):
                    updates['has_parking'] = True
                    logger.info(f"Extracted parking: yes (general affirmation) from message: {msg[:50]}")
                    break
        
        # Extract area (if missing)
        if 'area' in missing_fields:
            for msg in user_messages:
                msg_lower = msg.lower()
                
                # Only skip obvious frustration messages
                if any(phrase in msg_lower for phrase in [
                    'already told you', 'i already told you', '×›×‘×¨ ×××¨×ª×™ ×œ×š'
                ]):
                    continue  # Skip this message
                
                # Look for project-related responses
                if any(phrase in msg_lower for phrase in [
                    'sderot yerushalayim', 'sderot', 'yerushalayim', '×¡××˜×ª ×™×¨×•×©×œ×™×',
                    'neve sharet', 'neve', 'sharet', '× ×•×•×” ×©×¨×ª',
                    'afar house', 'afar', 'house', '××¤×¨ ×”××•×¡',
                    'anywhere', 'any project', 'any place', '×›×œ ××§×•×', 
                    '×œ× ××©× ×”', '×œ× ××›×¤×ª', 'open to', 'flexible'
                ]) or (len(msg.split()) <= 3 and not any(char.isdigit() for char in msg)):  # Short non-numeric responses
                    area = msg.strip()
                    if len(area) > 1:
                        updates['preferred_area'] = area
                        logger.info(f"Extracted area: {area} from message: {msg[:50]}")
                        break
        
        logger.info(f"Total extracted updates: {updates}")
        return updates
    
    def _extract_profile_data_from_message(self, field: str, message: str) -> Dict:
        """Extract profile data from message based on field type"""
        updates = {}
        
        if field == 'rooms':
            rooms = self._extract_number_from_message(message)
            if rooms and 1 <= rooms <= 10:
                updates['rooms'] = rooms
                
        elif field == 'budget':
            budget = self._extract_budget_from_message(message)
            if budget and budget > 0:
                updates['budget'] = budget
                
        elif field == 'parking':
            parking_response = self._analyze_yes_no_response(message, context='parking')
            if parking_response in ['yes', 'no']:
                updates['has_parking'] = (parking_response == 'yes')
                
        elif field == 'area':
            # Only extract area if it's actually about location preference, not frustration
            message_lower = message.lower()
            
            # Only skip obviously non-location responses
            if any(phrase in message_lower for phrase in [
                'already told you', 'i already told you', '×›×‘×¨ ×××¨×ª×™ ×œ×š'
            ]):
                return updates  # Don't extract area from obvious frustration
            
            # Only extract if it contains project-related keywords or is short project name
            area = message.strip()
            if area and len(area) > 1:
                # Check if it looks like a real project preference
                if any(keyword in message_lower for keyword in [
                    'sderot yerushalayim', 'sderot', 'yerushalayim', '×¡××˜×ª ×™×¨×•×©×œ×™×',
                    'neve sharet', 'neve', 'sharet', '× ×•×•×” ×©×¨×ª',
                    'afar house', 'afar', 'house', '××¤×¨ ×”××•×¡',
                    'anywhere', 'any project', 'any place', '×›×œ ××§×•×',
                    '×œ× ××©× ×”', '×œ× ××›×¤×ª', 'open to', 'flexible'
                ]) or len(area.split()) <= 3:  # Short responses likely to be project names
                    updates['preferred_area'] = area
        
        return updates
    
    def _extract_number_from_message(self, message: str) -> Optional[int]:
        """Extract number from message"""
        try:
            # Hebrew number words
            hebrew_numbers = {
                '××—×“': 1, '×©× ×™': 2, '×©×œ×•×©': 3, '××¨×‘×¢': 4, '×—××©': 5,
                '×©×©': 6, '×©×‘×¢': 7, '×©××•× ×”': 8, '×ª×©×¢': 9, '×¢×©×¨': 10,
                '××—×ª': 1, '×©×ª×™×™×': 2, '×©×œ×•×©×”': 3, '××¨×‘×¢×”': 4, '×—××™×©×”': 5
            }
            
            message_lower = message.lower()
            
            # Check for Hebrew number words
            for word, num in hebrew_numbers.items():
                if word in message_lower:
                    return num
            
            # Extract digits
            numbers = re.findall(r'\d+', message)
            if numbers:
                return int(numbers[0])
            
            return None
        except:
            return None
    
    def _extract_budget_from_message(self, message: str) -> Optional[float]:
        """Extract budget from message"""
        try:
            message_lower = message.lower()
            
            # Skip messages that are clearly about time/dates, not budget
            time_indicators = ['day', 'days', 'week', 'weeks', 'month', 'months', 'year', 'years', 
                             '×™×•×', '×™××™×', '×©×‘×•×¢', '×©×‘×•×¢×•×ª', '×—×•×“×©', '×—×•×“×©×™×', '×©× ×”', '×©× ×™×',
                             '××—×¨', 'today', 'tomorrow', 'next', '×”×‘×', '×‘×¢×•×“']
            
            if any(indicator in message_lower for indicator in time_indicators):
                return None
            
            # Skip messages that don't have budget-related keywords
            budget_keywords = ['budget', 'price', 'cost', 'pay', 'money', 'afford', '×©×›×™×¨×•×ª',
                             '×ª×§×¦×™×‘', '××—×™×¨', '×¢×œ×•×ª', '×œ×©×œ×', '×›×¡×£', '××œ×£', 'k', 'â‚ª', '×©"×—']
            
            if not any(keyword in message_lower for keyword in budget_keywords):
                # Only extract if it's a clear standalone number (like "5000")
                numbers = re.findall(r'\b\d{4,5}\b', message)  # Only 4-5 digit numbers
                if numbers:
                    budget = float(numbers[0])
                    if 1000 <= budget <= 50000:
                        return budget
                return None
            
            # Remove commas and extract numbers
            cleaned = re.sub(r'[,\s]', '', message)
            numbers = re.findall(r'\d+', cleaned)
            
            if numbers:
                budget = float(numbers[0])
                
                # Handle different units
                if 'k' in message_lower or '××œ×£' in message_lower:
                    budget *= 1000
                elif budget < 100 and any(keyword in message_lower for keyword in budget_keywords):
                    # Only multiply if it's clearly about budget
                    budget *= 1000
                
                # Reasonable budget range (1000-50000 NIS)
                if 1000 <= budget <= 50000:
                    return budget
            
            return None
        except:
            return None
    
    def _search_matching_properties(self, lead: Dict) -> List[Dict]:
        """Search for properties matching lead criteria"""
        try:
            search_criteria = {}
            
            if lead.get('rooms'):
                search_criteria['min_rooms'] = lead['rooms']
                search_criteria['max_rooms'] = lead['rooms']
            
            if lead.get('budget'):
                search_criteria['max_price'] = float(lead['budget'])
            
            if lead.get('has_parking') is not None:
                search_criteria['parking'] = lead['has_parking']
            
            logger.info(f"Searching properties with criteria: {search_criteria}")
            
            units = db_service.get_available_units(search_criteria)
            logger.info(f"Found {len(units)} matching units for lead {lead['id']}")
            
            return units
            
        except Exception as e:
            logger.error(f"Error searching properties for lead {lead['id']}: {e}")
            return []
    
    def _is_property_request(self, message: str) -> bool:
        """Check if message is requesting to see properties"""
        message_lower = message.lower()
        property_keywords = [
            '×“×™×¨×•×ª', '× ×›×¡×™×', '××¤×©×¨×•×™×•×ª', '××” ×™×©', '×ª×¦×™×’', '×ª×¨××”',
            '×‘×•× × ×¨××”', '××¦×', '×—×¤×©', '×™×© ×œ×›×', '×ª××•× ×•×ª', '×¤×¨×˜×™×'
        ]
        
        for keyword in property_keywords:
            if keyword in message_lower:
                return True
        return False
    
    
    def _ai_suggests_showing_properties(self, ai_response: str) -> bool:
        """Check if AI response suggests showing properties to the user"""
        response_lower = ai_response.lower()
        
        # Look for key phrases that indicate AI wants to show properties
        property_suggestion_phrases = [
            '×‘×•× ××¨××” ×œ×š', '×‘×•××• × ×¨××”', '××¦×™×’ ×œ×š', '×ª×¨××” ×œ×š',
            '×™×© ×œ×™', '××¦××ª×™', '×××¦×', 
            'let me show you', 'i will show', 'i found', 'let me find'
        ]
        
        for phrase in property_suggestion_phrases:
            if phrase in response_lower:
                return True
        
        return False
    
    def _is_scheduling_request(self, message: str) -> bool:
        """Check if message is requesting to schedule a tour"""
        message_lower = message.lower()
        
        # Strong scheduling indicators (high priority)
        strong_scheduling_phrases = [
            'lets schedule', 'let\'s schedule', 'schedule a tour', 'schedule tour', 
            'schdule', 'schedule', 'schedual',  # Common typos
            'book a tour', 'book tour', 'arrange a tour', 'arrange tour',
            'set up a tour', 'setup a tour', 'plan a tour', 'plan tour',
            'tor', 'toor', 'tour',  # Various spellings of tour
            '×œ×ª×× ×¡×™×•×¨', '×œ×§×‘×•×¢ ×¡×™×•×¨', '×¡×™×•×¨', '×‘×•××• × ×ª××', '×‘×•× × ×ª××'
        ]
        
        # Special case: if message contains "lets" or "let's" with schedule-related words
        if ('lets' in message_lower or 'let\'s' in message_lower) and any(word in message_lower for word in ['schedule', 'schdule', 'schedual', 'tour', 'tor', 'toor']):
            return True
        
        for phrase in strong_scheduling_phrases:
            if phrase in message_lower:
                return True
        
        # Check for scheduling-related keywords only if they appear with action words
        scheduling_keywords = [
            # Hebrew 
            '×¤×’×™×©×”', '×‘×™×§×•×¨', '×œ×¨××•×ª', '×œ×‘×•×', '×œ×ª××', '×–××Ÿ',
            '××ª×™', '××¤×©×¨', '× ×•×— ×œ×š', '×ª×™××•×', '×§×‘×™×¢×”',
            # English
            'schedule', 'meeting', 'appointment', 'visit', 'tour',
            'meet', 'when', 'time', 'book', 'arrange'
        ]
        
        action_words = [
            'lets', 'let\'s', 'can we', 'want to', 'need to', 'would like',
            'i want', 'we want', 'i need', 'we need', '×‘×•××•', '×‘×•×', '×× ×™ ×¨×•×¦×”',
            '×× ×—× ×• ×¨×•×¦×™×', '×¦×¨×™×š', '×¨×•×¦×”'
        ]
        
        # Check if message contains both action words and scheduling keywords
        has_action = any(action in message_lower for action in action_words)
        has_scheduling = any(keyword in message_lower for keyword in scheduling_keywords)
        
        if has_action and has_scheduling:
            return True
            
        return False


# Global lead service instance
lead_service = LeadService()